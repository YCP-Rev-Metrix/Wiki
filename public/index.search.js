var relearn_search_index = [
  {
    "content": "RevMetrix System Architecture Current Status by Development Team 2024 Fall BackendAll details about the current state of the backend development, along with what is planned for the future\n2024 Fall BallspinnerAll details about the current state of the backend development, along with what is planned for the future\n2024 Fall FrontendAll details about the current state of the backend development, along with what is planned for the future\n2024 Fall SimulationAll details about the current state of the backend development, along with what is planned for the future\n2024 Spring BackendAll details about the current state of the backend development, along with what is planned for the future\n2024 Spring FrontendAll details about the current state of the frontend development, along with what is planned for the future\n2024 Spring SimulationAll details about the current state of simulation development, along with what is planned for the future\n",
    "description": "The current state of each aspect of the project and what is to come",
    "tags": null,
    "title": " 2024 RevMetrix",
    "uri": "/2024-capstone/current-state-of-revmetrix/index.html"
  },
  {
    "content": " Download the .NET SDK https://dotnet.microsoft.com/en-us/download Run installer Open command prompt and run “dotnet” to confirm installation Confirm Visual Studio is updated to the appropriate version (can be found on the SDK download page) Check Version: Help → About Microsoft Visual Studio Update: Help → Check for Updates → Update Install .NET Upgrade Assistant Visual Studio → Extensions → Manage Extensions… Search for .NET Upgrade Assistant Click Install Close Visual Studio Click Modify on the pop-up Open Visual Studio again Right Click on the project file (for our solution, its BackEnd.csproj, FrontEnd.csproj, and Test.csproj) Click Upgrade Select upgrade option Repeat steps 5-7 for each .csproj file Upgrade the .NET Maui version installed Visual Studio → Tools → NuGet Package Manager → Manage NuGet Packages for Solution… Update Microsoft.Maui.Controls \u0026 Microsoft.Maui.Controls.Compatibility ",
    "description": "Instrucations",
    "tags": null,
    "title": ".Net Upgrade",
    "uri": "/2025-capstone/set-up/upgrade-.net/index.html"
  },
  {
    "content": "2024 Capstone 2024 RevMetrixThe current state of each aspect of the project and what is to come\nHow To ContributeTable of Contents Continuous Integration/DeploymentInformation about the project's CI/CD workflows\nContributing DocumentationHow to add, edit, and remove documentation on the Wiki\nDigitalOcean ManagementInformation regarding how to manage DigitalOcean Droplets\nDockerizing an ApplicationInformation on how to dockerize a project and deploy onto a separate machine or server\nGetting StartedInformation regarding setting up your development enviroment\nGetting StartedInformation regarding setting up your development enviroment\nGitHub WorkflowsAll GitHub workflows for the project\nInitial Project IdeasOriginal System Architecture Backend - Database ArchitectureUML diagrams representing the initial database architecture and schemas\nPhone App - Proof of ConceptDrawing board ideas for the layout and interaction methods of the phone application\nSimulation - First ThoughtsThe base ideas around using Unity for the development of a bowling simulation\nProject AssignmentsA list of all assignments completed throughout the fall 2023 semester\nProject MilestonesThe progress made prior to each project milestone\nTechnologies UsedA list of all of the necessary technologies to contribute to the project\n",
    "description": "2024 Capstone",
    "tags": null,
    "title": "2024 Capstone",
    "uri": "/2024-capstone/index.html"
  },
  {
    "content": "",
    "description": "All details about the current state of the backend development, along with what is planned for the future",
    "tags": null,
    "title": "2024 Fall Backend",
    "uri": "/2024-capstone/current-state-of-revmetrix/backend-fall2024/index.html"
  },
  {
    "content": "",
    "description": "All details about the current state of the backend development, along with what is planned for the future",
    "tags": null,
    "title": "2024 Fall Ballspinner",
    "uri": "/2024-capstone/current-state-of-revmetrix/ballspinner/index.html"
  },
  {
    "content": "",
    "description": "All details about the current state of the backend development, along with what is planned for the future",
    "tags": null,
    "title": "2024 Fall Frontend",
    "uri": "/2024-capstone/current-state-of-revmetrix/frontend-fall2024/index.html"
  },
  {
    "content": "",
    "description": "All details about the current state of the backend development, along with what is planned for the future",
    "tags": null,
    "title": "2024 Fall Simulation",
    "uri": "/2024-capstone/current-state-of-revmetrix/simulation-fall2024/index.html"
  },
  {
    "content": "Progress of Backend Development Backend Architecture Web API - Client and Server The Web API is now capable of making client-server interactions and is being hosted on a Linux Ubuntu 20.04 cloud server through DigitalOcean. To deploy the API application, a plethora of different approaches to the task were conducted, but in the end it was easiest and most efficient to create a Docker image for the application, create a docker-compose file for the application’s Dockerfile, and transfer this file to the DigitalOcean droplet in which the only installations needed on the server were Docker and SQLServer. Though the domain for the API will be changed further into the project, a test page for the API can be visited, but the link is currently being kept private for security reasons.\nBecause of the recent deployment of the API, the frontend team can now make secure data requests and transfers from the cloud databases inside of the mobile application.\nUpdated UML Diagrams - WebAPI Client Common Server Updated Database Schemas Below are the most recently updated reworkings of the project’s database schemas. The databases listed below can be seen in the RevMetrix System Architecture\nLocal Database Schema (Localhost) Backend Database Schema (Cloud Server) Both the User and Research databases have been combined into one database, with permissions set for raw data for the sole purpose of providing data to the Research UI.\nResults of database stress testing can be seen at the link below Database Observation DataAll data collected from database engine stress testing\n",
    "description": "All details about the current state of the backend development, along with what is planned for the future",
    "tags": null,
    "title": "2024 Spring Backend",
    "uri": "/2024-capstone/current-state-of-revmetrix/backend/index.html"
  },
  {
    "content": "Progress of Frontend Development Frontend Architecture Frontend User Interface Wireframes Local Testing Database Schema ",
    "description": "All details about the current state of the frontend development, along with what is planned for the future",
    "tags": null,
    "title": "2024 Spring Frontend",
    "uri": "/2024-capstone/current-state-of-revmetrix/frontend/index.html"
  },
  {
    "content": "Progress of Simulation Development Simulation Architecture Demo There should have been a video here but your browser does not seem\rto support it.\rSimulation Dataflow SmartDot Simulator Illustration Textured Lane and Gutters Setup Lane Reset Visual Pinsetter Development Preview Links SmartDot Simulator ",
    "description": "All details about the current state of simulation development, along with what is planned for the future",
    "tags": null,
    "title": "2024 Spring Simulation",
    "uri": "/2024-capstone/current-state-of-revmetrix/simulation/index.html"
  },
  {
    "content": "2025 Capstone 2025 Project Assignments2025 Capstone\n2025 RevMetrix2025 Capstone\n2025 Technologies Used2025 Capstone\nProject Milestones2025 spring Project Milestones Set up for help ",
    "description": "2025 Capstone",
    "tags": null,
    "title": "2025 Capstone",
    "uri": "/2025-capstone/index.html"
  },
  {
    "content": "\rProject Proposal2025 ",
    "description": "2025 Capstone",
    "tags": null,
    "title": "2025 Project Assignments",
    "uri": "/2025-capstone/project-assignments/index.html"
  },
  {
    "content": "\rBackendBackend 2025 spring Ball Spinner ApplicationFrontend 2025 spring\nBall Spinner ControllerBall Spinner Controller 2025 spring\nBallspinner Physical DesignBallspinner 2025 spring\nCloudInstrucations\nMobile ApplicationCellular\n",
    "description": "2025 Capstone",
    "tags": null,
    "title": "2025 RevMetrix",
    "uri": "/2025-capstone/cureent-state-of-revmetrix/index.html"
  },
  {
    "content": "Technologies Used The following is a list of all technologies used by the RevMetrix project, with descriptions of each technology and how it applies to the project.\nRaspberry PI The Raspberry Pi is a computer used by the Ball Spinner Controller. The current implementation uses a Raspberry PI 4 as shown in Figure 1.3.1, but the Raspberry PI 3 is also compatible.\nMetaMotionS The MetaMotionS is an inertial measurement unit that contains the same sensors as the proposed future SmartDot module. The MetaMotion module contains a gyroscope, accelerometer, magnetometer, barometer, temperature, and ambient light sensor, and it is currently being used to emulate the SmartDot module, which has not yet been constructed.\nCSVHelper CSVHelper is a C# .NET library that simplifies reading and writing CSV files, especially when working with POCOs. It maps CSV rows to POCOs or lists, provided the structure aligns and can write lists of POCOs with a simple WriteRecords() command. While not limited to POCOs, CSVHelper is integral to the RevMetrix project, where it efficiently handles parsing and writing local rev files stored as CSVs.\nDocker Docker is an open-source platform designed to simplify application creation, deployment, and management. It uses containerization to package applications and their dependencies into lightweight, portable units called containers. These containers ensure consistency across different environments, making developing, testing, and deploying applications easier. Docker is widely used to streamline DevOps workflows and enable scalability in cloud-based environments.\nDigital Ocean Digital Ocean is a cloud service provider that allows developers to easily create and manage virtual servers, called droplets, to host websites, applications, and databases. These droplets can run various operating systems and applications, making it easy to deploy custom environments. Digital Ocean also offers features like load balancing, automatic scaling, and managed databases, which enable users to scale their infrastructure as needed while maintaining high availability. Digital Ocean is commonly used to host web servers, APIs, and other production services.\nNginx Proxy Manager Nginx Proxy Manager is a web-based interface for managing Nginx reverse proxy setups. It simplifies tasks like configuring proxy hosts, setting up SSL certificates (with Let’s Encrypt), and managing multiple web applications on a single server without using the command line.\n.NET .NET is a C# software development framework that supports cross-platform compilation. .NET will be used as the primary platform for application and cloud development due to its cross-platform nature.\n.NET MAUI .NET MAUI is a multi-platform application framework that uses C# and XAML. As mentioned, it is compatible with Mac OS, Windows, iPhone, and Android. This technology will be used to create an application for Windows and Mac OS.\nThree.JS Three.JS is a javascript framework that adds the ability to draw 3D environments inside a web page. Like Chart.JS, Three.JS is open source and can be deployed to any platform. Using Three.JS enables rapid development as the language it is based on is high-level and reduces the steps needed to get a simple environment running.\nxUnit xUnit is a .NET testing framework with native integration with Github, allowing automated testing after any push. This testing framework also supports creating base classes to reduce code duplication, such as creating an instance of the application every time a test runs.\nASP.NET ASP.NET is a Microsoft framework for building web applications and APIs. It allows developers to create dynamic, scalable, and secure websites and services using .NET languages like C#. ASP.NET supports server-side and client-side development and includes routing, authentication, and data access features, making it a popular choice for enterprise-level web applications.\nPython Python is a high-level programming language designed for rapid development. In this project it will be used as the primary language for applications on the Raspberry Pi. Python is highly extensible and supports many libraries that enable the implementation of the Ball Spinner device.\nTINACloud TINACloud is an online application that allows users to digitally create and simulate circuits. TINACloud will be used to develop potential circuit designs and simulate the power regulation to confirm the integrity of crucial components such as the Raspberry PIs, as we are currently limited in supply.\nSolidWorks SolidWorks is computer-aided design software used to design all kinds of products and run analyses on them. The primary use for SolidWorks is to run Finite Element Analysis (FEA) or simulation on the designed products. These simulations allow us to test the viability of certain components under loading conditions and detect weak points.\nOnshape Onshape is cloud-native computer-aided design software for all kinds of products. It allows teams to collaborate on a shared design. The primary use of Onshape is to design parts and create designed parts assemblies. These assemblies can then be exported into SolidWorks for FEA simulations.\nGitHub GitHub is a cloud-based hosting website that uses Git, a version control software that enables developers to track changes and resolve conflicts. GitHub was used as the code repository for the various software components of the project, along with tracking changes to all software developed for the RevMetrix project.\nDraw.io Draw.io is a free online diagramming tool. Within RevMetrix, It was used primarily for creating UML diagrams.\n",
    "description": "2025 Capstone",
    "tags": null,
    "title": "2025 Technologies Used",
    "uri": "/2025-capstone/technologies-used/index.html"
  },
  {
    "content": "Frontend Team For this milestone, we will have skeletons of all pages. While most of the pages that are not needed by other teams will not function, they will at least be visible to the user. This lets the team establish better visual presentations based on feedback from the client. The team will implement a functional display graph that is capable of visualizing data in real-time.\nExample of how the output window will look\nExample of how the run window will look, notice that there is not precise information about the device that is connected\nExample of an alert box that will be needed for error handling\nExample of how the database management screen will look\nBackend Team For the 50% milestone, we will focus on several key factors that will enhance the functionality of our system. First, we will develop API endpoints designed for saving the simulation data. This will include endpoints to upload throw data, delete a throw, view throws (a list of previous throws), get devices, and view previous throw data. The get devices endpoint will be able to retrieve previous user SmartDot connections. This will include the SmartDot’s name and mac address, so BLE communication can be facilitated again between the application and the SmartDot. By this milestone, these endpoints will still be prototypes because we will not have all the necessary simulation data available. The endpoint we will have integrated with the frontend will be the upload throw endpoint which will contain its own Xunit tests, while the others will be integrated on the cloud and will be tested through postman. These endpoints will ensure that users can easily save and retrieve their simulation results. We will also implement the capability to parse throw data from one axis of rotation using the accelerometer sensor on the SmartDot. The operation of parsing the sensor data and sending to the simulation will run in real time, since this is a critical requirement of the application. This will be useful both for saving into the database and for transferring to the simulation so that the data can be more easily readable for these applications. In addition, we will integrate most of the endpoints within the server with the frontend. Thus, allowing the users to interact efficiently with the server and the frontend. With this, we will allow the users to operate the motors directly through the interface. This will be done by implementing scripting for one axis, therefore making it easier to automate and manage motor functions. At this point, the application will have readable data that can be displayed via the simulation page. Part of the frontend implementation of this page is to give the users the option to save simulation data locally into the new parsed file format (which we are calling .rev). So part of this milestone will also include prototyping a local save feature for the one-axis simulation data parsed into our custom file format. Users will also have the option to save data to the cloud, which will be achieved through the upload through the API endpoint. These accomplishments will be a significant step toward a fully operational system by enhancing functionality and user engagement.\nCommunications Team For the 50% working simulation on the communication side, the Ball Spinner will have the SmartDot API functions revolving around interfacing with the MetaMotionS completed. This will include (but is not limited to) reading 3-axis data from the magnetometer, gyroscope, and accelerometer, reading the light sensor data, and reading any information regarding the established Bluetooth connection. Interfacing with the MetaMotion module will be considered complete, which will include scripting to begin and end taking data from the respective sensors, and any other scripts required to run to automate the processes of the module. The system will then have a reliable source of data to interface with for data acquisition and message-passing comparisons.\nAlong with fully functional communication with the SmartDot module, the Ball Spinner Controller will be able to read and send data to the auxiliary sensors of the Ball Spinner. With the ability to reliably read the sensors connected to all the motors, the most important feature that will be completed by this milestone is to allow full control of at least one motor from the desktop side. This will involve a semi-finalized message-passing scheme between the Application and the Ball Spinner controller, where the controller will parse the message and send the data to the motor controller in a signal output that they would be able to understand.\nThe final task for the 50% working Simulation will be to finalize the establishment of connection on the Application side to both the Ball Spinner and the SmartDot module. Since the SmartDot is connecting to the Ball Spinner via BLE instead of connecting straight to the Application, extra message passing is required to ensure confirmation that the Application is not only connected to the Ball Spinner but the Ball Spinner is also connected to the SmartDot module. The user will be able to select the proper SmartDot module to connect to by selecting the MAC address (based on a list of available devices from the Ball Spinner) of the SmartDot module, which will then be sent to the Ball Spinner to establish the connection. From there, confirmation that everything went successfully will be sent back to the Application to be displayed to the user.\nMechanical Team The bowling ball will spin through motor input with control over two orthogonal axes of rotation. The major axis will be the main focus of the design. The minor axis will require less input power but still require a similar amount of control. Friction will be another critical point of consideration, especially since we want the ball to have its momentum influence the system. Reliable regulation of speed and acceleration will be vital.\nGiving the motors enough normal force between the ball and the points of contact will be challenging while the momentum maintains its impact on the system. Another important factor to consider is maintaining speed regulation with proper communication with the motors. Building the enclosure to handle the ball’s mass and momentum is essential. Creating a structure that can operate properly at the speeds we want will be demanding. Considering the general complexity of adding the second axis of rotation, constructing this system will be demanding.\nSimulation Team The 50% working simulation will incorporate a visual simulation that will be displayed alongside the graphs in the Application, removing the need for a console output. The accuracy of the simulation will continue to improve with the help of the mechanical team, communications team, and client by continuously improving on the calculations that the simulation runs off of.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "50% Working System ",
    "uri": "/2024-capstone/project-assignments/fall-2024/requirements/50-working-system/index.html"
  },
  {
    "content": "Abstract RevMetrix is a bowling analytics tool stemming from the idea to combine the visual bowling capture system designed by Dr. Babcock (the Ciclopes application), and a 3 Degree of Freedom (DOF) designed by Professor Hake (the SmartDot Module). The system will be designed to be able to combine data received from both sources and offer the end-user a cohesive representation of their bowling experience providing the ball’s direction of travel and speed during a game.\nThe focus of this project for the upcoming year is to develop a system that allows the user to enter variables surrounding the throw of a bowling ball. When the parameters are inserted, instructions will be drafted to manipulate the mechanism’s (Ball Spinner’s) motors to change the ball movement accordingly. The Ball Spinner will move the bowling ball in a way that replicates the movement as if the user would throw the ball with the entered credentials down an actual lane. From there, the user can watch a visual representation of the ball’s predicted movements as if it were on the lane. Datasets of the ball’s visual simulation and mechanical simulation will be graphed in real time, side by side. When finished collecting data for the session, the user will be able to either store the data in the RevMetrix database (as long as the user is logged in) or save the data in a .rev file.\nFor the minimal working system, the system will have a basic message passing between the Application and Ball Spinner to establish the communication protocols used for the two devices. The Application will also incorporate a working Login popup that stores the login credentials to the RevMetrix database. This will act as a proof of concept that interactions between the Application and database are functioning properly and data is stored in a retrievable format. On the mechanical side, the team will have a method of moving the ball in one orthogonal direction for data acquisition of the SmartDot module output data. Finally, the simulation team with incorporate a standalone text-based simulation that outputs information related to the future simulation calculations and variables.\nFor the 50% working system, message layouts and packet parsing methods will have been agreed on throughout the subsystems of the project. The skeleton for all of the pages and popups will be designed with a fully functional interface to the database and visual simulation when parameters are inserted into the Application. The User will have the ability to input data that will control the main motor of the Ball Spinner from the Application. The mechanical side will have a reliable control method for the ball in 2 orthogonal directions as well as communication with some of the motors to the Ball Spinner controller.\nFor the fully working system, all pages, popups, and error windows for the Application will be running and fully functioning. The User will be able to input parameters that control all motors of the Ball Spinner to move in their expected directions. The Ball Spinner will send the data from the auxiliary sensors along with the SmartDot module sensors back to the Application which will graph the data for the user. At the same time, the simulation will run, graphing the data for a side-by-side comparison for the user.\nMajor challenges for the project seem to be the lack of time for the team to reach the deadlines for each milestone due to the lack of time currently to experiment without working on deliverables and the short periods between each milestone for the current semester. Other challenges include message dropping from the communication standpoint, accurate simulation data, accurate Ball Spinner instructions, and not overwhelming the Ball Spinner Controller with extreme amounts of functionality.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Abstract",
    "uri": "/2024-capstone/project-assignments/fall-2024/requirements/abstract/index.html"
  },
  {
    "content": "Table of Contents What is an Endpoint? What is a controller? What is a POCO? What are Url Parameters? Common Rest Request Methods GET POST PUT PATCH DELETE Adding an Endpoint Basic Example Controller and Method Attributes Naming Returns Authentication and Authorization Returning Returning Data Returning Other Statuses Input Parameters Url Parameters Body Parameters Extra Notes Adding a Non-request Method to a Controller What is an Endpoint? An endpoint is a GET / POST … Rest API request method that may or may not take in parameters (body or url). This endpoint is what actually allows others to connect to the Web API and use it’s functionality. A full API Endpoint may look like: https://revmetrixapi.robertwood.dev/api/Test/TestTime. This specific endpoint is a GET that takes no parameters and returns the current server time in a POCO.\nWhat is a controller? A controller is a set of endpoints built around a common functionality. Currently, a good example is the User controller, which defines a lot of functionality related to creating, deleting, and logging in users.\nWhat is a POCO? POCO stands for ‘Plain Old Class Object’. These are classes who’s sole job is to contain data. An example is shown below:\npublic class DateTimePoco : POCO { public DateTime DateTime { get; set; } public DateTimePoco(DateTime dateTime) =\u003e DateTime = dateTime; }The above POCO contains one property (DateTime) of type DateTime and a constructor. There are no methods, data processing, or interactions with other objects. This allows it to be easily serialized and deserialized through json, something that the server and client handle for you (this is an easy process though).\nWhat are Url Parameters? Url parameters are a way by which key-value pairs are passed to the server via the plaintext url. In the example below, two values are set. This url defines a bing search for “Url Parameters” that displayes the first 11 results.\nhttps://www.bing.com/search?q=Url+Parameter\u0026first=11\nq (Query) = “Url Parameters” first (search results) = “11” This is used for many different API request methods but is not secure so it should not be used for private information.\nCommon Rest Request Methods HTTP Rest methods are the ways that the internet communicates, these each define a different style of DB call on the server. Though we don’t support all of the ones listed in the following site, you can learn more here.\nLearn about our supported methods below:\nGET A GET is about getting data, when executing a GET, you cannot provide information in the request body ut you can provide url parameters. This is normally used when the client is asking for data from the server, such as the TestTime example shown previously.\nPOST A POST is about the client sending data to the server, specifially sending new data to the server, that it would have to add a DB enrty for. In this, normally some value is provided to the server in the request body but may also be located in url parameters. A good example of this is the CreateAccount endpoint. In this, the body is expected to contain a POCO, representing the data being sent to the server. It is likely that during this, the server will reply with another POCO in the body aswell.\nPUT A PUT is about updating information on the server in the form of replacing it. This could be re-sending data that is currently in the DB. Here, the server would delete the old item, the add the new one. This is useful for large or very complicated updates.\nPATCH A PUT is about updating information on the server in the form of replacing only the changed values. A good example of this (not currently in use) could be a user requesting to update their username or phone number on the server. Here, the server only changes that specific database cell containing the username and everything else remains un-touched.\nDELETE A DELETE is about the client requesting that the server removes something from the DB. This is normally done through url parameters such as ‘id=5’, where the client wants to delete some item with the id of 5. There are currently no examples of this in the Web API. Generally, the result sent back from the server only relates to the success of this request though it may sometimes include the value of the item(s) deleted from the DB.\nAdding an Endpoint Basic Example Here, we have defined a basic endpoint, named ‘Test’ inside of the controller named ‘Demo’. Let’s deconstruct what it means:\n[ApiController] [Tags(\"Tests\")] [Route(\"api/tests/[controller]\")] public class DemoController : AbstractFeaturedController { [HttpGet(Name = \"Test\")] [ProducesResponseType(StatusCodes.Status200OK)] public IActionResult Test() { LogWriter.LogInfo(\"Test called\"); return Ok(); } }Controller and Method Attributes All controllers will extend from AbstractFeaturedController, which implements a few helper functions. This controller will be decorated with the attribute [ApiController] to let .NET know that this is an API controller. The Http method will be of return type IActionResult, decorated with [HttpGet(\"Test\", Name = \"Test\")], though this could have been a Post or other type previously covered.\nNaming The full endpoint url for this will be ‘baseurl/Demo/Test’ and this will be a GET. The name of the controller is always followed by the word controller. When the actual endpoints are generated, [Route(\"api/[controller]\")] lets the generator know to remove the word ‘Controller’ in the endpoint name. The name of our Http method is ‘Test’, denoted by the attribute [HttpGet(Name = \"Test\")] decorating the method.\n[ApiController] [Tags(\"\u003cType of Endpoint\u003e\")] [Route(\"api/\u003ctype of endpoint\u003e/[controller]\")] public class DemoController : AbstractFeaturedController { }This controller’s endpoint is api/tests/Demo.\nReturns This endpoint currently, just returns an Ok status 200 message to the client, though in future examples, we will see something a bit more useful. In order to let Swagger and our future self know what this can return, we can Decorate the method with the attribute [ProducesResponseType(StatusCodes.Status200OK)].\nAuthentication and Authorization In many instances, we want to limit who can use a specific endpoint. If we want to limit use to only users who are logged in, also granting us the abiity to grab the current user’s username, then we should add Authentication. If we want to limit use to only users who are of certain roles, like admin, user, or owner, we want to add Authorization.\nThis can be done by adding another attribute to either the controller or the http method. In the example below, only the methods have been decorated.\n[ApiController] [Tags(\"Tests\")] [Route(\"api/tests/[controller]\")] public class TestAuthController : AbstractFeaturedController { /// \u003csummary\u003e /// Tests to ensure that the accessing user is authenticated with a JWT /// \u003c/summary\u003e /// \u003creturns\u003e\u003csee cref=\"StatusCodes.Status200OK\"/\u003e | \u003csee cref=\"StatusCodes.Status403Forbidden\"/\u003e\u003c/returns\u003e [Authorize] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status403Forbidden)] [HttpGet(Name = \"TestAuthorize\")] public IActionResult TestAuthorize() { LogWriter.LogInfo(\"TestAuthorize called\"); return Ok(); } }By adding the [Authorize] attribute, we ensure that a user is logged in and has a valid JWT token.\nBy adding values into the [Authorize] attribute such as [Authorize(Roles = \"Admin\")] or [Authorize(Roles = \"Admin, Owner\")], we can lock this to only specific roles.\nHad we placed the attribute above the controller instead, all methods in the controller would ahere to that policy, shown below:\n[Authorize] [ApiController] [Tags(\"Tests\")] [Route(\"api/tests/[controller]\")] public class TestController : AbstractFeaturedController { [HttpGet(Name = \"TestAuthorize\")] public IActionResult TestAuthorize() { LogWriter.LogInfo(\"TestAuthorize called\"); return Ok(); } }Returning Returning Data At many points, we would like the server to return data during a client’s request, this through the use of POCOs. We can include in the return Ok() a POCO such as DateTimePoco. It will now look like return Ok(new DateTimePoco(DateTime.UtcNow)). This is automtically serializd into JSON and sent back in the body of the response.\n[HttpGet(Name = \"TestTime\")] public IActionResult TestTime() { LogWriter.LogInfo(\"TestTime called\"); return Ok(new DateTimePoco(DateTime.UtcNow)); }Ok (Status 200) is not the only status that contain information. Data may also be returned during a Forbid and others.\nThe last thing that we want to do, is decorate the method with it’s return types using the attribute [ProducesResponseType]:\n[ProducesResponseType(typeof(DateTimePoco), StatusCodes.Status200OK)] [HttpGet(Name = \"TestTime\")] public IActionResult TestTime() { LogWriter.LogInfo(\"TestTime called\"); return Ok(new DateTimePoco(DateTime.UtcNow)); }Here we are telling .NET that during a status 200, the method will return the DateTimePoco type.\nReturning Other Statuses At many points, we want to stop execution of a request early due to an error, invalid credentials, or something else. In order to do this, we have the ability to return more than just Ok (200). View here for a list and explanation of all statuses.\n[HttpPost(Name = \"Authorize\")] [ProducesResponseType(typeof(DualToken), StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status403Forbidden)] public async Task\u003cIActionResult\u003e Authorize([FromBody] UserIdentification userIdentification) { LogWriter.LogInfo(\"Authorize called\"); // Validate user credentials (e.g., check against a database) (bool success, string[]? roles) = await ServerState.UserStore.VerifyUser(userIdentification.Username, userIdentification.Password); if (success) { (string authorizationToken, byte[] refreshToken) = await ServerState.TokenStore.GenerateTokenSet(userIdentification.Username, roles); // Return the token as a response return Ok(new DualToken(authorizationToken, refreshToken)); } // If credentials are invalid, return a 403 Forbid response return Forbid(); }Above, we have definied a method which returns an Ok (200) with a DualToken POCO on success and returns Forbid (403) if the user’s credentials are invalid.\nWhen doing this, remember to annotate methods with the [ProducesResponseType] attributes:\n[ProducesResponseType(typeof(DualToken), StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status403Forbidden)]Input Parameters Input parameters are a crucial portion of every web API, allowing the client to communicate data to the server.\nUrl Parameters API Endpoints can take in Url Parameters. See the following code snippet to see how this can be done:\n[HttpGet(\"UrlParameterDemo\", Name = \"UrlParameterDemo\")] [ProducesResponseType(StatusCodes.Status200OK)] public IActionResult UrlParameterDemo([FromQuery] int parameter_name) { return Ok(); }By annotating a method parameter with [FromQuery], we can retrieve the values from the url parameters. Keep in mind that url parameters are not encrypted and therefore should not contain sensitive information.\nBody Parameters API Endpoints can also take in JSON items such as POCOs. THe code snippet below shows how to do this:\n[HttpGet(\"BodyParameterDemo\", Name = \"BodyParameterDemo\")] [ProducesResponseType(StatusCodes.Status200OK)] public IActionResult BodyParameterDemo([FromBody] DateTimePoco dateTime) { return Ok(); }By annotating a method parameter with [FromBody], we can retrieve the value from the request’s body. This is generally used with requests such as POSTs where data is transfered from the clients to the server. Keep in mind that this data is encrypted via HTTPS.\nExtra Notes Adding a Non-request Method to a Controller There are various instances in which you would like to have a helper function in a controller that doesn’t act as an API endpoint. If you have tried to to this, you have likely encountered an issue. To get around this, the method must be decorated with the [NonAction] attribute, letting .NET know that this method does not need to be an API endpoint.\nAn example is shown below, where the GetJWT method is decorated with the [NonAction] attribute.\n[Controller] public abstract class AbstractFeaturedController : ControllerBase { [NonAction] public string? GetJWT() { var AuthHeaders = HttpContext.Request.Headers[\"Authorization\"]; return AuthHeaders.FirstOrDefault()?.Split(\" \").Last(); } }",
    "description": "How to Add or Manage an Endpoint",
    "tags": null,
    "title": "Adding \u0026 Managing Endpoints",
    "uri": "/2024-capstone/how-to-contribute/webapi/endpoints/index.html"
  },
  {
    "content": "Official Project Requirements Document and Slideshow The official project requirements document can be found in the project’s Google Drive here, and the requirements presentation slideshow can be found here\nAbstract RevMetrix is a system that will record metrics of a bowling ball as it travels down the lane. It will consist of a physical device that the user can place inside a bowling ball and mobile application. The device will record rotational and positional data about the ball as it travels down the lane. It will periodically transmit this data to the mobile device to allow the user to understand what was happening to the ball when it was thrown. This will allow the user to improve their skill.\nSimulation The two main portions of the simulation architecture are the Unity Visualizer and the SmartDot simulator. Once complete, the Visualizer will be used to simulate a throw given initial parameters for the throw. The Visualizer will implement realistic physics to ensure that the ball and pins behave exactly as they would in real life. Additionally, simulated data will be collected from the Visualizer and used, alongside data from a binary dump file, to test the SmartDot Simulator. The SmartDot Simulator will simulate the physical device that will be used to get the data. The simulator will sample data from the Visualizer and store, then transmit that data like the SmartDot module would. This data will be transmitted to the mobile device via bluetooth.\nFrontend The frontend section of the diagram is the Mobile Application, Ciclops, the SmartDotAPI, and the File Reader. The Mobile Application serves the designed UI to the end-user of the project. It also transmits all relevant input gathered from the user to the Cloud infrastructure by saving it to a Local Database which is then transmitted to the Cloud. Along with this, the Mobile Application facilitates gathering all user input, whether it is the user inputting a new ball or the user recording a video of them bowling with a new or pre-existing ball. Ciclops will take a video file and use image-processing to extract data from video. The Ciclops program will be able to take the user’s videos and generate positional data for the ball over the throw and then send it to the database. Finally, the SmartDot API will communicate between the mobile app and the SmartDot module within the ball. Currently our plan is to use the API plugins affiliated with the MBIENT Labs Bluetooth IMU to test and further develop bluetooth functionality. We will then work with the backend team to reference their API in constructing our own.\nBackend The backend section of the diagram is made up of the local database, the client side of the Web API, and the cloud-infrastructure which includes both the research and user databases, algorithm unit, cloud controller, and the server side of the Web API. The cloud-infrastructure is accessed through the mobile application by client/server interactions using the Web API. Each interaction is encoded with SSL encryption to ensure the security of any data being sent to or from the server. The local database is stored on the mobile device and stores the user’s most recent practice or match session data.\nCommunication Protocols Secure Socket Layer (SSL) encryption is used to encrypt and decrypt data that is being sent through the Web API in order to ensure the security of that data. Since the data being sent through the Web API will include usernames, passwords, and other possibly valuable data, it must be encrypted to ensure the digital safety of the application’s users. Bluetooth communications will be implemented into the ISmartDot interface in order to receive information from the SmartDot module located inside of the bowling ball. This data will be sent to the SmartDot API and used in the mobile application. SmartDot Module and ISmartDot Interface The SmartDot module is the physical device that will be placed into the bowling ball. It will record positional and rotational data about the ball as it travels down the lane. It will periodically transmit that data to the mobile device for the user to analyze. It will communicate with the mobile device through the ISmartDot interface. The interface will consist of a few commands for reading and writing data to the SmartDot module. In this way, the system will be able to record metrics about the ball and present it to the user.\nAnalysis and Design by Type of Develeopment Backend TeamProject Analysis and Design specific to the backend team\nFrontend TeamProject Analysis and Design specific to the frontend team\nSimulation TeamProject Analysis and Design specific to the simulation team\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Analysis and Design",
    "uri": "/2024-capstone/project-assignments/fall-2023/analysis-and-design/index.html"
  },
  {
    "content": "Overview Below you can find the list of project assignments completed throughout the fall 2024 semester and all of their details.\nList of Assignments BackendDesign and Analysis Information and Links to the Document and Slideshow\nBall Spinner ControllerDesign and Analysis Information and Links to the Document and Slideshow\nBall Spinner ProtocalDesign and Analysis Information and Links to the Document and Slideshow\nBallSpinnerDesign and Analysis Information and Links to the Document and Slideshow\nDataBase SchemaDesign and Analysis Information and Links to the Document and Slideshow\nFrontend Design and Analysis Information and Links to the Document and Slideshow\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Analysis and Design",
    "uri": "/2024-capstone/project-assignments/fall-2024/analysis-and-design/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: awatkins1@ycp.edu External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Andrew Watkins ",
    "uri": "/more/members/andrew-watkins/index.html"
  },
  {
    "content": " Ball Spinner The Ball Spinner will provide 4 DoF (degrees of freedom) to drive the bowling ball in 3 orthogonal rotations, and one linear translation. Only one motor (the primary motor) will be required to produce a substantial driving force to replicate movement down the lane. The other motors (the secondary/tertiary motors) require only minimal force as the ball has the ability to shift vertically depending on the angle the ball is thrown and the angular velocity given to the ball before the release of the bowler. Once prompted by the Front-End Application, the Ball Spinner will increase/decrease motor speeds and send this data back to the application, along with output from different auxiliary sensors to fully encapsulate the motion of the bowling ball.\nFront End Application The Application will maintain its current implementation of the .NET MAUI infrastructure with a heavier focus on the already multi-platformed application running on a Windows or Mac Environment. Some of the current functionality only works on the mobile platform and has difficulties in simulating in the development environment. With the idea that the Ball Spinner will be controlled with a computer, the desktop configuration seems to be the primary platform for the application to run on. The application will allow the user to connect to the Ball Spinner controller through USB. Once connected to the hardware, the user will be asked to input turn-specific credentials relating to the physics of how the ball would be thrown in a real-world scenario. This would include Launch Angle, Initial Velocity, the weight of the ball, and the type of core the user’s bowling ball possesses. These parameters will then be passed to the Ball Spinner which will replicate and transmit data back to the application.\nSmart Dot Module The SmartDot module is a 9 DoF module containing an Accelerometer, Magnetometer, and Gyroscope outputted data in 3 axes. This module is the primary device used for receiving information from inside the bowling ball. The module will be installed in the bowling ball underneath a finger insert in an existing finger hole. When the Ball Spinner begins emulation, the SmartDot module will send its data to the motor controller via BLE. For testing purposes, other 9 DoF modules will be used that share the same communication method as this module such as the MetaMotion module from Mbient labs.\nBall Spinner Controller The Ball Spinner controller will receive the parameters from the user interface in order to calculate the changing angular acceleration, center of mass, and overall physics of the bowling ball from the initial throw. From there, the controller will generate instructions to send to the motor controllers describing specific motor speeds and duration. At the same time, the controller will send readings from both the motors and auxiliary sensors back to the front-end application to be displayed to the user.\nSimulation As long as all connections are stable to the SmartDot and Ball Spinner, a simulation will appear demonstrating how the ball would interact going down an actual lane, displaying speeds, trajectory, and the primary access point of the ball. To display the 3D viewport, Three.js, and a Webview will be used. Three.js will be used instead of Unity Engine, Evergine, Monogame, or Veldrid because of the simple requirements the viewport has. Also, Unity Engine is completely overkill and does not support being embedded in a Maui application. We will also implement the ability to upload previous SmartDot shot data to display this simulation for both the current simulated run and the previous shot data so that we can test the ball spinner. The idea is that we would try to replicate the previous shot with the parameters given to the ball spinner, and using the real generated data, we can compare the graphical display and the various accelerometer, gyroscope, magnetometer, and ambient light sensor graphs that will be displayed for both scenarios to ensure they are as close to each other as possible\nBackend (Server) The development of the backend will be a continuation of last year’s cloud infrastructure. A key focus will be setting up a local database, allowing for prototyping without affecting the primary system. To achieve this, we will configure a docker container containing a separate SQL server. Additionally, we will need to update the current database schema to include a simulated shots table for the cloud database and the local application database. This table will store all data inputted by the user via the front-end application and data retrieved from SmartDot. Lastly, we will further develop endpoints to support data transfer between the front end and server.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Architecture",
    "uri": "/2024-capstone/project-assignments/fall-2024/proposal/architecture/index.html"
  },
  {
    "content": "Overview This information is short and straightforward. Any info needed about setting up the backend team’s development environment can be found on the GitHub Workflow - Backend page.\n",
    "description": "How to setup your development environment for the backend",
    "tags": null,
    "title": "Backend",
    "uri": "/2024-capstone/how-to-contribute/getting-started/backend/index.html"
  },
  {
    "content": " Christian Lua-Lua, Ryan Curry Server The image above shows our UML diagram for the RevMetrix server. The main job of the server is to give RevMetrix users the ability to access the database for storage of their RevMetrix data. The web server is created by the WebApplicationBuilder class, which binds API endpoints to controllers, binds the middleware used for authorization, and sets other options that dictate server build attributes. The ServerState class defines a set of modules that are essential for proper operation of the server. This functionality is provided by the SecurityHandler, the DatabaseUserStore, DatabaseTokenStore, and the RevMetrixDB. The SecurityHandler generates JWT tokens and refresh tokens which are used to authorize users. It also Handles hashing and salting user passwords for storing in the database as well as authorization of user JWTs, which is essential for a secure web server. The DatabaseUserStore provides an interface for storing important user data in the database such as username, salt, password, and user roles. This class also provides an interface for authenticating a user through the Sequence equal method which checks to see if the hashed password the user entered is equal to the user’s hashed password in the database. The DatabaseTokenStore provides functionality for storing, retrieving and deleting user tokens. The RevMetrixDB is the DAO (Data access object) which actually interacts with the database, retrieving, storing, and deleting objects within the database as instructed by the server. All of the above-mentioned classes that interact with the database use the RevMetrixDB class in order to do so. The revmetrix-db is the regular database used for retrieving/storing user data. While the revmetrix-db-test database is going to be a test database used for testing endpoints and DAO methods, as we will need an external database with dummy data for those tests so we do not mess with any user data. All of these aspects of the database allow for proper security and user interaction with the server.\nWhen the server is created a routing table is generated based on the directives indicated within the APIController classes. When a request is made to the server, the endpoint that the user sent is mapped to a Controller class. These API controllers use Microsoft’s AspNetCore package to map themselves to an API endpoint, that will then be directed to the APIController’s task method based on the way the directives direct the endpoints. The task methods perform whatever task is required of the endpoint(GET, POST, or DELETE) and return a response to the server. If a request is seeking database data, the response sent back to the server will be in the form of a POCO. A POCO stands for plain class object, and it is used to map database data to a class object so that the client can receive the data in a more readable format. The controllers interface with the above mentioned RevMetrixDB, DatabaseUserStore, and DatabaseTokenStore classes to perform the user specified operation which mainly involves adding, deleting, and retrieving information from the database. Other operations that can be performed by these endpoints include authenticating users and generating new JWT and refresh tokens, and deleting JWT/refresh tokens.\nEarlier it was mentioned that the WebApplicationBuilder class uses middleware to authenticate users, and that the middleware used is defined when starting up the server. For our purposes, the middleware that authorizes a user’s JWT token is managed by part of the SecurityHandler class. When the [Authorize] directive is specified in the API controller, the AuthorizationSigningTokenKey method will check the signature of the JWT token, and if it is valid, allow the user to continue, else it will return an unauthorized response. Another important piece of middleware is the verifyJWTBlackListMiddleware class. This operation also runs when an endpoint requires authentication, and ensures that the user requesting access to the server is not using an invalid token.\nA response, which can consist of data or a boolean indicating success is then sent back to the APIController where a proper Http Response containing data (or an error indication) is then sent back to the client. This is indicated in our UML by the Server, Router, and APIController blocks. Each APIController class inherits from the AbstractFeatureController class, which provides methods for retrieving the current user’s username and JWT token, for any endpoints that require authorization. The AbstractFeatureController class inherits from the ControllerBase class, which is a part of Microsoft’s AspNetCore package and is essential for endpoint development. The ControllerBase class is what allows the APIControllers to operate as such.\nBallSpinner Interface and Parser Logic The above diagram displays the BallSpinner functionality and the parser logic for our application. This starts with the BallSpinner Functionality Module which provides an interface between the application page models and the IBallSpinner. This module provides important BallSpinner functionality to the application models like facilitating a connection with the BallSpinner controller, sending instructions to the BallSpinnerController to start a simulated session, and halting the BallSpinnerController operations. The actual connection and implementation of these methods is done by the BallSpinner. The BallSpinner implements the IBallSpinner interface and connects to the BallSpinner controller through a USB connection, and verifies the connection is valid through the acknowledgement protocol, which is described in greater detail within the Procol section of this paper. It also includes error handling, if the BallSpinner controller returns an error message or some other communication error occurs, this will be sent back to the BallSpinner Functionality module where the error will be sent to the models to be displayed to the user. Furthermore, methods like SendBackListOfSmartDots() are available to allow the user to view a list of SmartDots sent to the application by the BallSpinner controller. Users can view each SmartDot and their available frequencies for each sensor, and select a SmartDot and set its frequencies on the application. This data will then be sent to the BallSpinner controller as a part of the setSmartDot() function, which will run through the initial connection protocol described within the Protocol section of this paper setting up a connection with the SmartDot module. Once a connection is established with the BallSpinner and a SmartDot module, the BallSpinner is able to start the BallSpinner controller and send the physical instructions needed by the BallSpinner controller to operate the motors. When SmartDot data is received from the BallSpinner, the DataParser is invoked which handles sending parsed data to the simulation and the visualizer to be used for a graphical display. It will also write this data to a temporary rev file, which if a user chooses can be saved locally or to the cloud database after the simulation is completed. The .rev file is essentially a formatted csv file which stores a list of samples in the following format:\nThe acronyms for each column are as follows (in order): sensor type, sample count, sample number, sample data, and elapsed time. This will allow for ease of use when interpreting this data and uploading it to the database.\nPlain Old Classic Objects (POCOs) The diagram to the side represents various Plain Old Class Objects (POCOs) that serve as data models for the backend. Each class contains very simple functionality and holds specific attributes and basic getter/setter methods. For example, the user object stores personal details like first name, last name, and contact information. The BallList object contains multiple balls, which are their object and contain attributes such as weight, hardness, and core type. Additionally, both the SmartDot and BallSpinner objects represent sensors that each is associated with the simulated shot and can be used for tracking data via a MAC address to monitor performance metrics. Lastly, the SimulatedShot object captures shot attempts and integrates data from ShotInfo with sensor data recorded by SensorFrequencies and SensorData. These POCOs are important for our backend because they allow the simplification of the data management process. Lastly, the main functionality of these POCOs is to be used by the Object-Relational Mapping (ORM) Framework to map these objects to corresponding database tables.\nClient This diagram represents the client from the API architecture where it is possible to interact with a backend via HTTP requests and responses from the front end. In this case, AbstractTokenStore manages authentication tokens, providing methods to get and set the token. The IDatabase interface defines core operations like user login, registration, and managing various entities. The Database (Client) class implements the IDatabase interface making it possible to interact with the backend. Last from the diagram, the MockDatabase is a test version used for simulating backend interactions which will contain a lot of dummy data. Overall, the design will support both live operations and testing through mock objects.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Backend",
    "uri": "/2024-capstone/project-assignments/fall-2024/analysis-and-design/backend/index.html"
  },
  {
    "content": "Database Overview: The Revmetrix project seeks to provide comprehensive tools for bowlers and researchers who can use the provided metrics to improve their game or study the physics of bowling. These tools provided to the end user take the form of the Ball Spinner Application and the Mobile Application, both of which require a database schema to serve the goals of the project. The Ball Spinner application schema is tailored for researchers aiming to refine the algorithms that generate bowling metrics, with a focus on simulated shot data collected through the BSA. In contrast, the Mobile Application schema emphasizes usability and game tracking, offering data more relevant to a bowler’s personal performance.\nOverall Architecture The overall architecture of the RevMetrix database schema stores bowler data (from the Mobile App) along with research data (from the Ball Spinner App). A comprehensive view of the integrated schema is pictured in Figure 1. The mobile schema is towards the left and the Ball Spinner App schema towards the right, with shared parent tables in the center to minimize redundancy across both schemas.\nThis integrated schema will be cloud-hosted and used by both the Ball Spinner and Mobile applications to back up their respective data.\nCurrent BSA Schema Figure 2 displays the schema used for the BSA. This implementation currently resides on the cloud hosted on a Digital Ocean server. This provides RevMetrix researchers centralized access to a wealth of simulated shot data, enabling further refinement of the signal processing algorithms that provide bowling metrics.\nRelevant data includes simulated shots with initial parameters, the ball used, and associated SmartDot sensor data collected from the shot.\nMobile Schema Figure 3 represents the overall architecture of the mobile application and its cloud integration. Data is stored locally on the user’s device using SQLite and synchronized with an existing cloud database. Because two applications, the App and BSA, share access to the same database, the schema includes inherited tables containing shared information. Each application can then extend these base tables with additional, application-specific data as needed.\n",
    "description": "Backend 2025 spring ",
    "tags": null,
    "title": "Backend",
    "uri": "/2025-capstone/cureent-state-of-revmetrix/backend/index.html"
  },
  {
    "content": "Architecture Initial Database Architecture Local Database (Localhost) Local Database Schema User Database (Cloud Server) User Database Schema Raw Database (Cloud Server) Raw Database Schema ",
    "description": "UML diagrams representing the initial database architecture and schemas",
    "tags": null,
    "title": "Backend - Database Architecture",
    "uri": "/2024-capstone/initial-project-ideas/initial-database-architecture/index.html"
  },
  {
    "content": " Jordan Carvell, Braden Fleming, Victor Pineda, Robert Wood Backend Architecture Minimal Working System The Backend Team’s role in the project will consist of three main objectives: Creation and maintenance of the Cloud Databases (User and Raw Binary databases) and the local phone database, creation and implementation of the Web API (allowing for client-server interactions), and the development and integration of ISmartDot interface. For the minimal working system, the most important goal to complete will be the decision of which database engine(s) will be used to read and write data between the different technologies used. Once the decision is made, we will need to create the database tables and enable read/write functionality to and from each database’s respective locations. Finally, to complete the minimal working system, we will need to complete the development of the Web API to effectively request and receive data to and from the mobile application and each database.\nIssues Communication between the local and cloud databases may serve as an obstacle due to the possibility of using a different database engine for the local database than the cloud databases use. Hosting the Web Server in a way that allows it to be accessed from anywhere. SSL certificates and network security may get in the way of this.\n50% Working System In the 50% working system, the system components have the ability to communicate with each other. Most of the features for the system will not be implemented, such as a Cloud Controller with basic features; the ability to read the data and format it, or to pass the data to either the Raw and/or User database. What will be functioning is an API client whether it is a dummy or a primary functioning API client that communicates to the basic functioning cloud controller using WebAPI.\nFinal Working System The final working system will have a fully functional system with the ability to communicate throughout the system. The API client will communicate to the Web API that talks to the Cloud controller which can talk to at least one of the databases and give the data back to the cloud controller. The Cloud Controller then transfers data to the Web API which then gives the data to an API Client.\n",
    "description": "Project requirements specific to the backend development",
    "tags": null,
    "title": "Backend Requirements",
    "uri": "/2024-capstone/project-assignments/fall-2023/project-requirements/backend/index.html"
  },
  {
    "content": " Jordan Carvell, Braden Fleming, Victor Pineda, Robert Wood Local Database The local database will be used to store and retrieve information from the current or most recent practice/match session that the user completed. The mobile app sends the session’s data to the local database and overwrites previous data entries when a new practice/match session is completed and the previous data has been uploaded to the user database in the cloud. This is done initially on the phone app to ensure that data is not lost.\nWeb API - Server The Web API server is the endpoint of the web API that the frontend team can interact with via the client code. This will house controllers and logic to talk to the database, authenticate \u0026 authorize users, and preform algorithmic analysis when necessary.\nWeb API - Client The Web API client is a purpose built C# utility devised to make communications with the Web API server simpler, implementing automatic error handling, request abstraction, POCO conversions, encryption, and authentication. This means that when it comes time to integrate the client into the mobile application, little will need to be done.\nCommon The common project will hold common classes and architecture between the Server, client, and other projects within cloud infrastructure. This will consist of primarily logging-related classes and POCOs.\nAlgorithm Unit The algorithm unit will contain many algorithms developed by Professor Hake during his thesis. These will largely be implemented by other students and exists to determine ball \u0026 throw statistics \u0026 metrics from primarily raw data from the Research Database. This may eventually house algorithms relating to video processing as well.\nUser Database The User database will be storing all of the information from the SmartDot module and Ciclops. It will store all of the User/Game details and then a connection will be established via a Web Api to the phone application that will read and write information to or from the cloud-based database.\nResearch Database The research database is going to hold the raw data that is collected from the Smart Dot Module. This entire database will have a similar layout to the User Database, but instead of being used for displaying purposes it will be utilized for Professor Hake’s analysis. This Database will be used for algorithm development.\nUML Diagrams Web API - Server Web API - Client Common Algorithm Unit A UML diagram has not been devised for this as no algorithm development has taken place.\nDatabase Interface Diagrams User Database Local Database Research Database Database Schemas Local Database User Database Research Database ",
    "description": "Project Analysis and Design specific to the backend team",
    "tags": null,
    "title": "Backend Team",
    "uri": "/2024-capstone/project-assignments/fall-2023/analysis-and-design/backend/index.html"
  },
  {
    "content": "Ball Spinner Application Overview The purpose of the Ball Spinner Application (BSA) is to provide an interface for controlling and receiving data from the Ball Spinner as well as the SmartDot. Ball Spinner data, along with user related data used to facilitate Simulated Shots with the Ball Spinner, is also saved to the cloud database. Users are provided with a streamlined view (Figure 1) that displays all relevant data received during a shot. This includes a graphical representation of incoming SmartDot data, as well as a simulation that visually displays the movement of the ball as it spins in the Ball Spinner.\nShots Once connected to the Ball Spinner, the user can begin a Simulated Shot, a session controlled by the BSA. The user first sets initial values, including start, end, and inflection points on a Bézier curve (Figure 2), which defines the interpolated motor instructions (shown in red). They must also specify the ball used and add any comments. From here, the shot can commence.\nWhen a shot begins, motor instructions are sent to the Ball Spinner Controller, which then returns sensor data from the SmartDot and motor encoder readings. This data is used to animate the simulation and update the corresponding graphs.\nCommunication The Ball Spinner Application uses a TCP connection to facilitate communication with the Ball Spinner Controller.\nThe BSA primarily sends the following key commands: Motor instructions SmartDot configuration Start/Stop commands for shot initiation\nUser Data sers can save shots and balls to the database, both of which are managed on the pages pictured on the right. Saved shots can be reused for new simulations and managed through replay or deletion.\n",
    "description": "Frontend 2025 spring",
    "tags": null,
    "title": "Ball Spinner Application",
    "uri": "/2025-capstone/cureent-state-of-revmetrix/frontend/index.html"
  },
  {
    "content": "Downloading the Ball Spinner Application Visual Studio community 2022 link: https://visualstudio.microsoft.com/vs/community/ Screenshot for what to select in visual studio installer: When visual studio opens click “Clone Repository”: Enter this url into the “Repository location” field https://github.com/YCP-Rev-Metrix/BallSpinner-Application When the project opens, go to Tools - Nuget Package Manager - Package Manager Settings: For the name field, enter RevMetrix, and for the source, enter https://nuget.pkg.github.com/YCP-Rev-Metrix/index.json n the same menu, go under Package source mapping When opening visual studio, you will be prompted to enter your github credentials. This is necessary in order to access some of the custom nuget packages. Enter the command dotnet workload restore to install required nuget dependencies for the project When asked if Visual Studio can make changes to your device, select yes. Troubleshooting Issues: Ryan Issues If this window pops up Then toggle the button under Developer Mode Run these commands within the project directory: dotnet clean dotnet restore Frontend Josh’s Setup issues: Today I got Visual Studio 2022 installed on my laptop. I copied both the Backend and Frontend repositories to my system. I was able to follow the wiki for setting up the backend. I learned that the frontend page has an old repository and informed everyone else. We got the correct repository link from Patrick.\nNext we had an issue where any time any of the Juniors would run the frontend application, we would get an “Unauthorized” error. To fix this we had to get added to the RevMetrix GitHub.\nAfter this the error message changed to a “Failed to retrieve information about ‘RevMetrix.BallSpinner.Common.Api’ from remote source ‘https://nuget.pkg.github.com/YCP-Rev-Metrix/download/revmetrix.ballspinner.common.api/index.json'. Response status code does not indicate success: 403 (Forbidden)”. To solve this issue I had to start by following the steps from the image below to remove old github credentials from my laptop.\nNext I had to generate a new personal access token in github and add the NuGet package to visual studio. For the token, I selected all the scopes and copied it to store somewhere safe. Next I went back into visual studio and navigated to tools-\u003eNuGet Package Manager-\u003ePackage Manager Settings-\u003ePackage Sources. I clicked the plus icon as seen in the image below. In the source field at the bottom I input “https://nuget.pkg.github.com/YCP-Rev-Metrix/index.json”. After this I rebooted visual studio and was prompted with credentials. For the username I entered my github username, and for the password I pasted in the token I created. Next I tried to run the Ball Spinner application again and everything booted up fine! ",
    "description": "Instrucations",
    "tags": null,
    "title": "Ball Spinner Application",
    "uri": "/2025-capstone/set-up/ballspinner-application/index.html"
  },
  {
    "content": " Robert Fields The Ball Spinner Controller can be split into 3 separate (but crucial) classes that all come together to transmit and receive data from the Ball Spinner Application: the motor class, the sensor class, and the SmartDot interface. The motor and sensor classes consist of a connection function that takes the name of the port as a parameter and a disconnect function. The auxiliary sensor class (AuxSensor) also incorporates a read function that takes in the range of values to read from and the sample rate for the sensors. This will take the data polled from the sensors and store it in the class-byte array. The motor function (along with the connect/disconnect methods) incorporates a function to change the power of a specific motor depending on the specific motor instruction and a function to change the speed of the motor from the incoming motor instructions.\nThe smartDot interface will hold all of the functions that the future SmartDot module will incorporate. This includes the start functions of the 9DoF sensors and the light sensor that takes sample rate and the range as parameters coupled with stop functions for each. When prompted by the BallSpinnerController class, the 9DoF modules will pass the values taken at the specified sample frequency in the byte array. For filtering in the Bluetooth scanner, each class that implements the iSmartDot interface will store its UUID as a Static String. Besides a terminal-base SmartDot simulator, the only class so far that will implement the interface is a MetaMotionS module that has functions to turn on and off the on-sensor LED light.\nThe BallSpinnerController will have access to both the AuxSensor class, Motor class, and the iSmartDot module as well as several variables that will handle communications back and forth from the Application. On startup, the three threads will be started up to handle communications for each of the main classes discussed previously mentioned. The BallSpinnerController class will listen to the USB port for all messages from the application, and from there, the readCommsChannel function will parse the header and the number of bytes in the message to parse out the cyclic redundancy check appended to the end of every message to confirm that the message there were no errors in transmission. If so, a call to the sendReject function will be made to ask to the application to resend the message. This function will also handle the quick acknowledgments or errors that need to be sent from the controller. If the CRC passes, the readCommsChannel will pass the message to either the sensorBuffer, the motorBuffer, or the smartDot buffer. depending on which buffer the message was sent to, the respective thread will parse out the message and handle the message depending on the request. Once the protocol reaches the point that the BallSpinnerController needs to send the messages back to the Ball Spinner Application, the byte data for the message will be saved in the sensorTxQueue to await send on the comms channel.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Ball Spinner Controller",
    "uri": "/2024-capstone/project-assignments/fall-2024/analysis-and-design/ball-spinner-contoller/index.html"
  },
  {
    "content": "Overview Ball Spinner Controller (BSC) acts as intermediary between Ball Spinner Application (BSA) and Ball Spinner Data from Sensors is sent to the BSA and graphed against simulated data of the expected sensor data Human Machine Interface (HMI) is 7” touch screen interaction assistant, standalone driver, and debugger for the BSC. The HMI can be run in local mode and control all hardware within the BSC The HMI can also graph and display the sensor data\nBSC Communication The BSC at its core is a communication hub, with 5 separate types of devices that are interacted with, all fed through the Raspberry Pi 4 The Ball Spinner Application – connected over WIFI using TCP for wireless control over Ball Spinner Data Current Sensor IC’s – connected to an ADC transmitting using I2C to read current through each motor Motor Encoders – connected to 5 digital inputs on Raspberry Pi to read data, enable movement, and change direction MetaMotionS Module – connected over Bluetooth BLE as the 9 Degrees of Freedom module inside of the bowling ball, sending accelerometer, gyroscope, magnetometer, and light sensor data All Data communication is displayed through the HMI to allow for user interactions\nBSC Implementation The BSC stores the power supply for the system along with the PCB for the system\nThe PCB contains terminal blocks to connect all wires from the motors and encoders to the Raspberry Pi GPIO pins to allow for 2 Degrees of Freedom of the Ball Spinner.\nAll components are packaged inside of a 3D-printed housing with connections to external components feeding out of the back of the Controller\nThe user interacts with the Pi using the 7” touch screen display to start the software in either wireless mode or local testing mode.\n",
    "description": "Ball Spinner Controller 2025 spring",
    "tags": null,
    "title": "Ball Spinner Controller",
    "uri": "/2025-capstone/cureent-state-of-revmetrix/bsc/index.html"
  },
  {
    "content": " Logan Tyran, Ryan Curry, Robert Fields Ball Spinner Protocol The structure of the protocol can be split into three separate operations: connecting to the Ball Spinner Controller, connecting to the SmartDot module, and sending the real-time data to and from the Ball Spinner Controller. Each message will contain a header byte that will hold the hex code for the type of message followed by a byte that incorporates the message size. There is no specific size for each message, so the message size byte will be used to locate the end of the message on both sides of the system. For error detection, a 2-byte cyclic redundancy check (CRC-16) will be appended to each message. If an error is found on either side of the system, a rejection message will be sent out which will contain the supposed header byte for the other side to resend that last message.\nTo initialize the connection between the Application and the Ball Spinner Controller, the Application will first send the initialization message which consists of the MAC address of the Application. This data acts more as “dummy data” and is not particularly important for the connection besides filling up the message size to a total of 10 bytes. The Ball Spinner Controller, which is continuously reading the port, will send an acknowledgment message back to the Application, in which the Application will consider the connection established. The acknowledgment and error messages will both contain 1 byte (along with the aforementioned overhead data) which will contain a hex code for the specific type of acknowledgment or error.\nTo confirm connection to the SmartDot module, the application will send the initiate BLE signal which contains 2 Bytes to hold the integer value for the rate that the Ball Spinner Controller should be scanning for Bluetooth devices. From there, the Ball Spinner will continuously send the Bluetooth device message, which contains the name of the Bluetooth device and the MAC address. The name will be in ASCII characters with the max value being 248 bytes (including the null terminator). The Ball Spinner Controller will be sent at the specified scan rate that will also send repeated scanned values to avoid the need to send a rejection message in case an error is detected. When the user selects the appropriate module to connect to, the Application will send the MAC address of the smartDot module, which once received from the Ball Spinner Controller will stop sending the Bluetooth device message to the Application (which will act as a confirmation that the BSC received the message) and attempt to connect to the MAC Address. On connection, the Ball Spinner Controller will either send the SmartDot Confirmation message or an Error Message. The Ball Spinner Controller message will consist of the SmartDot MAC Address, and a byte for each sensor that will hold another hex code representing the max sample rates for the Accelerometer, Gyroscope, Magnetometer, and light sensor. Once the Application receives the confirmation message, the application will recognized to the user then a connection will be established. If the Application receives the error message, the Application will need to resend the BLE scan signal and restart the operation from the beginning.\nThe final and most elaborate operation of the Ball Spinner Protocol starts from the Application sending the initiate sensor message consisting of a bit-mapping for both the sample frequency and range for each sensor in the Ball Spinner. There will be two bits representing the 4 possible ranges for the scan data (2, 4, 8, 16) and an additional 3 bits for the 7 possible sample frequencies to scan at (25, 50, 100, 200, 400, 800, 1600). This will be sent for the Accelerometer, Magnetometer, Gyroscope, Light Sensor, and the 3 auxiliary sensors for a total of 35 bits stored among 5 bytes (leaving 5 zero bits). When the initiate sensor message is received from the Ball Spinner Controller, it will send an acknowledgment and wait for the application to send the Motor Instructions message. This will consist of a byte for the speed for each motor (3 Bytes total). After receiving the first motor instruction, the Ball Spinner Controller will continuously send the sensor data from the various sensors. Each Sensor data message will contain a byte that will store the type of sensor (using 3 bits to represent the 7 sensors) and the sensor’s sample rate (using 3 bits to represent the possible sample rates previously established in the initiate sensor message). Along with that, it will contain a byte for the count of the sample for that sensor, a float that stores the elapsed time (4 bytes), and finally a float for the x,y, and z axis values (4 bytes each) for a total of 37 Bytes for the sensor data. Every so often the Application will send an acknowledgment that no frames have been lost which will be determined by the sample count number from each sensor. Every time a sensor receives an out-of-order frame, the Application will send a rejection message with the number required to resend. Finally, when the roll is finished, the Application will send the Stop message which will just be an Error message with the error code correlating to the stop function.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Ball Spinner Protocal",
    "uri": "/2024-capstone/project-assignments/fall-2024/analysis-and-design/ball-spinner-protocol/index.html"
  },
  {
    "content": " Chris Robinson, David Kyeremeh, Sam Diskin BallSpinner Enclosure Given the ball’s mass and size, an enclosure will be built to secure it while allowing free rotation using ball bearings. The enclosure for the bowling ball must be sturdy to ensure that the system remains stable and does not fail or break during operation, especially considering the forces exerted by the motors and the ball’s weight. It will be designed to withstand repeated use and any mechanical stresses generated during the ball’s rotation. We will ensure the enclosure will accommodate bowling balls of different sizes. The enclosure will also be see-through, allowing the user to monitor the process.\nMotors \u0026 Drivers (Frictional forces) {setup, power, friction} Each motor will be spaced 90 degrees apart; the three motors will drive the bowling ball using friction. The motors will be mounted to the enclosure utilizing springs, ensuring the necessary normal force is maintained to drive the ball effectively. The motor on the primary spin axis will be capable of spinning the ball at 60 RPM, providing the main rotational force. The motors on the secondary and tertiary axes will rotate at speeds below 10 RPM, contributing minor adjustments to control the ball’s movement without interfering with the primary rotation.\nSensors The SmartDot will be positioned inside the bowling ball, approximately three and a half inches away from its geometric center. The auxiliary sensors will measure the bowling ball’s real-time angular velocity and send this feedback to the Raspberry Pi for processing. One idea being discussed is making holes in our driver and then using a light sensor to count the rpm so there is a verifiable measure of the motor input. The ball’s angular velocity may be measured by a small motor normal to the ball. The ball will spin the motor through friction, causing the motor to generate a voltage. The voltage can be measured to obtain the motor’s angular velocity, which can be compared to the bowling ball through a process akin to gear ratios.\nMotor Controller \u0026 Power Supply The motor controller will primarily consist of a MOSFET circuit powered by laptop chargers and controlled by the Raspberry Pi. The Pi only needs to provide a small electrical signal to allow the chargers to power the motor. The signal will look like a square pulse wave modulation (PWM) signal. The duty cycle is calculated by the Pi and will adjust in real-time. Each motor will have a dedicated MOSFET circuit, but may share power supplies depending on future configurations and design implantation. One of the primary reasons to use a laptop charger is that they provide safe and stable DC power at an appropriate voltage for our system.\nRaspberry Pi The Raspberry Pi acts as the central hub of data for the BallSpinner; It talks to the external systems, the external sensors, SmartDot module, and motor controllers. The Pi will send the calculated motor power requirements to the motor controllers, this signal will be a low-voltage PWM. This signal will be rapidly changing based on the feedback data from the rest of the system. Without this component, the bowling ball would remain idle.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "BallSpinner",
    "uri": "/2024-capstone/project-assignments/fall-2024/analysis-and-design/ballspinner/index.html"
  },
  {
    "content": "Physical System Exploded View of the Physical Model: 2x 2”x4”x36” wood blocks used to support the ball and house the bearings 2x plywood pieces to mount motor and serve as base 1x steel axle rod 0.8” OD ± 0.01” Extra material serves as minor counterweight Axle rod to be threaded for vice handle and lock nut clamping mechanism (future Implementation) 1x 34Y307D-LW8 NEMA 34 stepper motor w/ a E5-500-394-I-D D-G-B motor encoder mounted onto the rear Mounted using aluminum faceplates that screw into the wood block faces Resting on top vibration dampening, foam, material Utilizes a padded shim to offset motor tilt 3-D printed cups are sized to house the foam ball and hold it in place using screws The physical model is constructed using two pieces of wood measuring 3.5”x1.5”x36” and two plywood pieces to serve as base and motor mount. The vice axle (left) side is made using a steel rod machined down to 0.8” OD ± 0.01” so as to fit within the single bearing mounted within the vice axle side. The extra length of the axle rod serves as a minor counterweight and will be threaded to mount a vice handle lock nut system, future implementation, this axle feeds through the bearing and into the cup which it is then locked into. The motor on top is a 34Y307D-LW8 NEMA 34 stepper motor with a E5-500-394-I-D-D-G-B encoder mounted onto the rear. The motor rests on a piece of dampening material (foam) and is mounted to the system by using an aluminum face-plate which is screwed onto the system and face of the motor. The motor is geared using a 1.25:1 ratio and connected to the motor axle via chain, which is held taught by chain tensioners mounted below the face plate. The motor axle is constructed using a dowel rod that was sanded and modified to fit the bearings that are both mounted within the motor side of the system. Side View of the Physical Model Showing the Chain Assembly: The exposed chain measures around 40” in length when unlinked and connects a 6” OD 3 teeth/inch spur gear to a ~4.8” OD 3 teeth/inch spur gear. This results in a 1.25:1 gearing ratio that is driven via the stepper motor. Chain tensioners are implemented to keep the chain action smooth and consistent, especially since this axis will experience the highest level of rotation and is not currently guarded outside of the enclosure. Motor Mounting Plate:\n3 ½” by 7 ½” aluminum plate Four small through holes with a 0.217 inch diameter (through holes for screwing into face of motor) Each through hole is spaced 2.740 inches apart The radius of the large through hole is 1.438 inches (fits snugly around the notch of the motor) The primary purpose of the motor mounting plate is to securely hold the motor steady in place preventing any lateral movement during operation. The motor mounting plate is screwed into the face of the motor and into the 2x 2”x4”x36” wood blocks. The Motor Mounting Plate is made out of an 6061 T6 aluminum plate with a thickness of ⅛”.\nManufacturing Process for Motor Mounting Plate: The machine used to manufacture the Motor Mounting Plate was the water jet cutter (Insert name of model). In order to manufacture a piece on the water jet cutter you must follow the steps below. (After part has been created)\nExport to DXF file Select file Select Export to DXF/DWF Save file (make sure you are in the correct units) Upload DXF file to a USB drive Insert USB drive into Dell laptop for the water jet cutter Select ProtoMax Layout Import your DXF file Select ProtoMax Make Import your Layout file from Promax Layout Select autopath Pitch and Yaw Rotation Model: This miniaturized model was intended to demonstrate the methods by which the model will need to rotate as well as for our team to visualize how to motorize them. For the top (Yaw) plate, the team was looking to motorize the system through a direct drive pancake motor seated underneath the bottom plate, which is connected to the top plate through a “lazy susan”, and through the central hole of the “lazy susan” to drive the top plate. The side (Pitch) legs house an axle that allows for rotation freely and angled cuts set to 45°. This side would be motorized through rotation of the axle or some equivalent method. Model Representation of Vice Axle Mounting Mechanism: A model that depicts the method by which the steel axle rod was intended to be threaded to allow for clamping and withdrawal of the cup from the ball to facilitate no-slip rotation as well as removal/replacement of the ball if necessary or desired. Proposed System 1st Axis Relies on a vice grip system with lock nuts to induce a clamping force to prevent slippage. Driven by gear and chain 2nd Axis Rotates the previous sub-system utilizing a direct drive motor paired with a lazy susan to pivot up to 90 degrees in either lateral direction 3rd Axis Directly driven to tilt the previous sub-systems up to 45 degrees in either direction.\nBowling Ball Insert The insert will allow the SmartDot chip to remain in the bowling ball securely as it spins. It must hold the chip at the right depth of the bowling ball while having clear view for the light sensor on the chip.\nTarget numbers The goal for the primary axis of rotation is 750 RPM while the secondary axis needs 10 RPM and the third axis only need 2.5 RPM. For a 16 lbs bowling the vice would need a clamping force of only 35 lbs.\n",
    "description": "Ballspinner 2025 spring",
    "tags": null,
    "title": "Ballspinner Physical Design",
    "uri": "/2025-capstone/cureent-state-of-revmetrix/ballspinner/index.html"
  },
  {
    "content": "Project Contributions WebAPI development NuGet package creation and management Backend development Contact Information Institution Email: bfleming2@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Braden Fleming",
    "uri": "/more/members/braden-fleming/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Brandon Woodward",
    "uri": "/more/members/brandon-woodward/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: bneptune@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Bryce Neptune",
    "uri": "/more/members/bryce-neptune/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Byers Joshua",
    "uri": "/more/members/josh-byers/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Carson ",
    "uri": "/more/members/carson-mack/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Chris Robinson",
    "uri": "/more/members/chris-robinson/index.html"
  },
  {
    "content": "Description Ciclopes will be used to detect objects from videos/a camera to the mobile app.\nPrerequisites Microsoft Office 365 - This is needed for your program to work with excel files\nGit\nCUDA\nDevelopment Enviroment The SmartDot Simulator is currently being developed in JetBrains Rider. This tutorial will show you to set up Rider and begin developing the Simulator. JetBrains Rider is a cross-platform .NET IDE based on the IntelliJ platform and ReSharper. Let’s get started!\nFirst, let’s install PyCharm.\nInstall PyCharm if you do not already have it Next, let’s configure it. Ciclopes-YOLO\nClone the Ciclopes-YOLO Repo repository https://github.com/YCP-Rev-Metrix/Ciclopes-YOLO.git Ciclopes-OpenCV\nClone the Ciclopes-OpenCV Repo repository https://github.com/YCP-Rev-Metrix/Ciclopes-OpenCV.git Ciclopes-Mobile\nClone the Ciclopes-Mobile Repo repository https://github.com/YCP-Rev-Metrix/Ciclopes-Mobile.git Open the repository in PyCharm run pip install requirements.txt in the terminal Now, you are ready to start developing Ciclopes!! Have Fun, and be safe!\n",
    "description": "How to setup your environment to develop the Ciclopes",
    "tags": null,
    "title": "Ciclopes",
    "uri": "/2024-capstone/how-to-contribute/getting-started/ciclopes/index.html"
  },
  {
    "content": "Ciclopes is a software developed by Dr. Babcock. It is designed to detect and trace the path of the bowling ball that has traveled down a lane from an external view. The input is a video file that requires calibration based on the camera position but can generally be placed in any position that has visibility of the full lane. This software lets users easily view their bowling shots’ external metrics. It is one of the two legacy innovations of the RevMetrix project.\n",
    "description": "2025 Capstone",
    "tags": null,
    "title": "Ciclopes",
    "uri": "/ciclopes/index.html"
  },
  {
    "content": "Publishing Nuget Packages Nuget is a package repository provided by Microsoft for .NET projects. It integrates very nicely with Github such that users can publish Nuget packages to a specific Github repo-sitory. This also enables permission-specific downloads related to NuGet packages, so no one outside of the Github organization can download or make changes to the Nuget package. For the RevMetrix project, we have our own Nuget package called RevMetrix.Ballspinner.Common.API. This package contains all classes defined within the Common module within the BallSpinner-Cloud repository: The Common module contains all of the POCO (standing for Plain Old Class Object) classes that are used for client-side/server-side ORM (object relational mapping). That is why we publish it as a Nuget package, so that the client-side ORM can match that of the server. This allows for consistency in terms of the database objects being sent to and from the server and also further simplifies API migrations that can easily be updated client-side through the Nuget package.\nIn order to contribute to the RevMetrix.BallSpinner.Common.API Nuget package, you will need to first package the module (after you have made your necessary changes) and then you will need to use the dotnet nuget push command to push it to the RevMetrix repository. Before you can publish Nuget packages, you will need to create a nuget.config within the Common modules directory. A nuget.config file contains your credentials as well as the repository location that will be needed to properly push the package. Here is a template that you can use for the nuget.config file:\nThis configuration file defines the repository location with the tag and contains your github credentials within the tag. Copy this file and place it into the Common directory and replace the “ClearTextPasswordKey” with a valid github token. As long as you are within the YCP-Rev-Metrix organization, you will be able to push to this repository. Refer to this documentation for creating Github tokens if you are unsure how to do so https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens. Make sure to at least provide read and write permissions to the token. IMPORTANT!!! MAKE SURE YOU INCLUDE THIS NUGET.CONFIG FILE INTO YOUR GIT IGNORE LIST BECAUSE IT CONTAINS YOUR TOKEN. From here, you are ready to contribute to the RevMetrix.BallSpinner.Common.API Nuget package.\nHere is how you package a module in Visual Studio:\nThis is the .csproj file for the module. It defines the module as a Nuget package with the version 1.1.8, as denoted by the tag. When you are ready to pack the module, increment the version number and then right click on the module package and select pack: From a powershell window change the directory to go into the Common folder and run the command dotnet nuget push “bin/Debug/RevMetrix.BallSpinner.Common.API.1.1.9.nupkg” –source “github”. This will push the Nuget package to the RevMetrix repository using the nuget.config file created earlier for the source location and credentials. This package can then be installed on the application with the Nuget package manager. ",
    "description": "Instrucations",
    "tags": null,
    "title": "Cloud",
    "uri": "/2025-capstone/cureent-state-of-revmetrix/cloud/index.html"
  },
  {
    "content": "Table of Contents Continuous Integration/Deployment Basics ",
    "description": "Information about the project's CI/CD workflows",
    "tags": null,
    "title": "Continuous Integration/Deployment",
    "uri": "/2024-capstone/how-to-contribute/ci-and-cd/index.html"
  },
  {
    "content": "Contributing documentation is pretty straightforward, follow this basic guide to learn how.\nA brief history This page was built with the Hugo framework \u0026 static site generator using the Relearn theme and hosted on GitHub Pages. Every commit to the main branch will trigger a GitHub Action, causing the page to rebuild itself. This takes only a minute or two before the changes are updated. This structure provides a beautiful site, solid uptime, and the ability to even make edits in the GitHub web editor.\nEditing existing pages Navigate to the page that you would like edit and select the icon in the top right of the page. See Learning the syntax for more information on making edits.\nCreating new pages \u0026 sections Create a new folder, named whatever you want inside of content/\u003cdesired location\u003e. Create a new file here named _index.md, this file will contain your page’s content. If sub-pages are desired, add a new file titled \u003cfilename.md\u003e inside of your newest folder. See Relearn Theme Docs for better documentation.\nLearning the syntax The syntax used here can be as simple as Markdown (Discord uses this), however, may get more advanced if you want something fancy.\nThe following two guides are excellent sources for learning Markdown:\nRelearn Theme Docs Markdown Docs This framework also allows the use of HTML code instead of Markdown, however, Shortcodes may be better suited to what you want to do.\nThe following two references may help you learn the Shortcodes that may be used:\nRelearn Shortcodes Hugo Shortcodes Making local edits In order to make local edits on your own machine, we will need to follow a couple of steps:\nInstall Git if you do not already have it Install Hugo (Extended edition) Install Go Clone https://github.com/YCP-Rev-Metrix/Wiki.git in your favorite IDE or terminal Open a Git terminal in the directory of your new repository. For VS users, this can be (Toolbar) Git \u003e Open in command prompt Launch a live server by calling hugo serve (git or wsl terminal) Navigate a browser to http://localhost:1313/Wiki Make changes (mostly in content directory). After saving, you should see the page refresh live. After making your changes, push or merge your changes back up to the main branch. Your changes will now be reflected on the WWW in a few minutes. ",
    "description": "How to add, edit, and remove documentation on the Wiki",
    "tags": null,
    "title": "Contributing Documentation",
    "uri": "/2024-capstone/how-to-contribute/contributing-documentation/index.html"
  },
  {
    "content": "Prerequisites Before continuing with any of the following steps, make sure to create an account on DigitalOcean\nCreating a New Project After creating an account, login and head over to the dashboard. From here, in the top left of the page, click the “New Project” button as seen below:\nFill out the necessary fields, and in the “move resources into …” window, click “skip this step” at the bottom to move on since the droplet is being made from scratch.\nCreating a New Droplet To Start After creating a new project, click on the project’s name in the top left of the page under the “Projects” dropdown. This will take you to the project’s dashboard. From here, go ahead and click the “Create” dropdown button in the top menu bar on the project’s dashboard page as seen below:\nFrom here, select the “Droplets” option to continue:\nThis will take you to the specifications portion of creating the droplet, where you’ll select your Region, Datacenter, Image, Size, CPU Options, Additional Storage, and Authentication Method.\nRegion Selecting a region is purely preference, but for optimal performance it is safe to pick the region closest to where the devices are that the applications on the Droplet will be talking to. Selecting a region looks similar to the following image:\nDatacenter Once a region for the Droplet is selected, go ahead and select a datacenter as seen below:\n*Note: It is recommended to choose a datacenter that is close to you or to the application on the Droplet’s users.\nImage Moving forward, select the disk image that you want to use. There are plenty of options, but the standard image to use is a Linux Ubuntu image as they are the most convenient for server-side development. The selection section will look like the following:\nThough the newest version of Ubuntu (23.10 x64) is available on DigitalOcean, it is recommended to use Ubuntu 20.04 x64 as it is the version that currently has long term support (LTS). You can change the version using the dropdown pictured below:\nSize The next specification to choose is the size, which includes the Droplet type and the CPU options. It is simpler to stick with the basic options for now, but you may change the type of droplet and increase memory as needed. The recommended options for a basic Droplet are shown below:\n*Note: The size of the Droplet can be increased after creation, but the size can not be decreased.\nAdditional Storage and Authentication Method After choosing the size of the Droplet, it is time to decide on the addition of extra volumes and the authentication method of the Droplet. Adding additional volumes is optional, however it is recommended in the event that the applications one plans to host on the droplet and their data are expected to need to be relocated later on.\nOn the other hand, it is required to select an authentication method in order to access the Droplet. The authentication method can be chosen based off of preference, but the easiest way to access a Droplet is by setting a password for the “root” user. This way, the console can be accessed through the Droplet’s dashboard and there won’t be a hassle of adding SSH keys to certain machines. Select either option, as seen below:\nRecommended Options Though the following options are recommended, they are not required. However, since the “Add improved metrics monitoring and alerting” option is free and provides the ability to collect and graph expanded system-level metrics, track performance, and set up alerts instantly within the control panel, go ahead and select it as seen here:\nFinalize To complete the creation of the Droplet, go to the “Finalize Details” section (seen below) and select the number of Droplets you wish to create, give each of them a name (either automatically generated or user-specified), and select which project to assign the Droplet(s) to.\nOnce this section is filled out, hit the “Create Droplet” button in the bottom right, as pictured here:\n*Note: You may create the Droplet via Command Line, however, it is easier to do so by the method above.\nConclusion Your Droplet is now created and ready to be used. To view the newly created Droplet, click on the project you’ve assigned it to in the top left of the dashboard page under the “Projects” dropdown, then select the Droplet from the list of them on the project’s dashboard. There, you will find all of the information regarding the new Droplet.\nFor information on how to access the Droplet’s console, view its data usage, and more check out the “Managing a Droplet” page.\n",
    "description": "How to create a DigitalOcean Droplet",
    "tags": null,
    "title": "Creating a Droplet",
    "uri": "/2024-capstone/how-to-contribute/digitalocean-management/creating-a-droplet/index.html"
  },
  {
    "content": "Front End Application The Mobile Application was built using a .NET MAUI framework that provides cross-platform functionality all in C#. The current version of the application takes in data from the Ciclopes program, the SmartDot API, and Unity Engine, which then stores the data in a local database. The application will receive further updates to allow the user to feed in bowling variables and operate the Ball Spinner. The Ciclopes and Unity Visualizer will have little to no updates, as they are not currently the focus of the RevMetrix project.\nThe Backend The backend currently consists of multiple important functionalities, including the Web API Server, the Web API Client, the Cloud Controller, and the RevMetrix Database. The Web API incorporates both server and client-side interfacing, making it possible for the front-end application to communicate with the databases within the server. The Cloud Controller determines traffic flow in and out of the cloud server. Finally, the Database is used to store all the data gathered from both the SmartDot and the front-end application. In future phases of the project, the Algorithm Unit will be developed and incorporated as part of the Backend which will contain Dr. Babcock and Professor Hake’s algorithms and endpoints.\nRevMetrix Documentation Website The RevMetrix Website is the main location where all the documentation surrounding the project is stored. The website is currently hosted by DigitalOcean and contains the current state of the project, installation tutorials, resources, and ways to contribute to the project. The User Interface includes a search engine on the left-hand side with all of the information neatly categorized into seven sections/subsections. The website will continue to receive updated documentation on what the current system looks like as well as changes to configuring the development environment. The website will also receive structural changes to categorization to make sifting through information easier for users.\nUnity Bowling Simulation The Unity Engine was used as a minimal working simulation software. Users of the mobile application could change the location and the curvature of the bowling ball before it was thrown. The simulation displays the ball’s speed and rotation and allows users to see the ball’s trajectory as it moves down the lane. Finally, Unity simulates the ball-hitting pins and how the pins react (i.e. their trajectory on impact and any other pins that might be affected). The Unity Engine will be used as a starting basis for the simulation side of the project, with improvement upon what currently exists to mimic what the Ball Spinner is mechanically producing.\nSmartDot Simulator The SmartDot Simulator is a .NET MAUI application made to convert data sent from either the Unity Engine or from pre-recorded SmartDot data and send the information as byte arrays similar to what the SmartDot module would send to the application.\nSmartDot Communications The SmartDot Communication process involved running a GATT server on a Raspberry Pi which handled the BLE communication. Data from the SmartDot module was then sent through Byte Arrays to the Pi, and from there to the application. The software used for SmartDot communication will be used in\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Current System",
    "uri": "/2024-capstone/project-assignments/fall-2024/proposal/current-system/index.html"
  },
  {
    "content": "Below is all of the data collected from our database engine stress testing\nMaking 100-million entries in each database engine The Databases orginally tested were PostgreSQL, MySQL, and MongoDB.\nMongoDB was removed from the list of candidates for our database due to the read/write speeds of the others being significantly faster than its own.\nDelete, Update, and Add operations in PostgreSQL \u0026 MySQL PostgreSQL and MySQL tables and performance graphs Due to the large performance difference between PostgreSQL and MySQL, the MySQL database engine was most likely to be removed. However, we continued to test it against the other engines in the event that at higher rates/speeds, it out performed them.\nSQL Server was recommended by Professor Hake, so we looked into it and began testing it against the PostgreSQL and MySQL engines.\nSQL Server tables and performance graphs Adding a single row in each engine Due to the significant differences in speed between SQL Server and PostgreSQL, along with MySQL, we have decided to use SQL Server as our primary database engine for RevMetrix.\n",
    "description": "All data collected from database engine stress testing",
    "tags": null,
    "title": "Database Observation Data",
    "uri": "/2024-capstone/current-state-of-revmetrix/backend/database-obsevation-data/index.html"
  },
  {
    "content": " Christian Lua-Lua, Ryan Curry Database Schema The database schema above consists of multiple interconnected tables designed for efficient data storage. At a glance, this schema enables the us to track and store user data, simulated shot information, and acquire real-time metrics from auxiliary and SmartDot sensors. At the core of our database schema is the User table, this table allows us to store personal information like usernames, passwords, and contact details. Additionally, each user has an associated token that manages authentication by storing a token value and its expiration date. Furthermore, the schema allows the user to have one list for each type, whether from Balls, BallSpinners, SmartDots, or SimulatedShots. These list tables use foreign keys to reference the respective items, which store the details of each entry. Lastly, each list can hold zero or more items.\nAnother important table that is associated directly with the user would be the SimulatedShot table. This table differs from the others because each entry will be a bowling shot that has parameters and relationships with the BallSpinnerSensors and SmartDotSensors. The parameters stored in this table are the initial speed, angle, and position of the bowling ball. This schema also contains multiple sensor-related tables. Furthermore, the tables labeled BallSpinnerSensors and SmartDotSensors are specific to their respective devices. The BallSpinnerSensors table will store data acquired from the three auxiliary sensors depending on the type of sensor (roll, pitch, and yaw). Additionally, the SimulatedShots table can have one SmartDotSensors table which relates the simulated shot to all of the SmartDot sensor data. Each SmartDotSensors table references foreign keys for each SmartDot sensor which refer to the sensor table. The sensor table stores the sample frequency and the number of samples per queue for each sensor, this data coupled with the time data stored by the queue table and the order indicated by each sample within a queue will be used client side to redetermine the timestamp for each sample. Each sensor has a list of queues which is referred to by the one to many relationship between the Sensor table and the Sensor Sample Queue ID list. Each queue has an initial and elapsed time and has a one to many relationship with the Sensor Sample Data table, because each queue holds a set of samples. Each sample is what actually contains the values for the SmartDot data. There is also an order column, which indicates the samples order within the queue. This is also essential in reconstructing the time data for each sample, as the order determines the sample’s completion time relative to the other samples. In the case that there is a column that is not applicable for a given sensor (for instance brightness value is not needed for a gyroscope) these values will be left null if not needed for a sample. Creating these relationships between the SmartDot sensors table and its children, provides a decluttered and organized way of viewing and retrieving data as opposed to storing all information into one table.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "DataBase Schema",
    "uri": "/2024-capstone/project-assignments/fall-2024/analysis-and-design/database-schema/index.html"
  },
  {
    "content": "Project Contributions Created Ciclopes software Contact Information Institution Email: dbabcock@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "David Babcock",
    "uri": "/more/members/david-babcock/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "David Kyeremeh",
    "uri": "/more/members/david-kyeremeh/index.html"
  },
  {
    "content": "Minimal Working System Sensors Light sensors and reflective tape can allow us to constantly measure how quickly the ball rotates about a single axis. This approach cannot work well if there is rotation about the other axis as there is a chance that the reflective tape will not be in front of the light sensor after each revolution. Motor feedback from small motors mounted in each orthogonal direction. The friction the ball imparts will generate some electricity that we can interpret to measure how quickly the ball rotates in each direction.\nHamster Ball Design One of the ideas for a prototype design is to tape the SmartDot (or, in this case, MetaMotion) module on the inside of a hamster ball. The positioning of the sensor inside the hamster ball will be roughly the same distance away from the center of the bowling ball. This will act as a smaller and easier-to-move version of the bowling ball, allowing the software team to acclimate with the SmartDot Sensors, while the mechanical team will use this to test ways to accurately and consistently manipulate the ball in each rotation.\nRip-Cord Design The Rip-Cord design involves tightening a cord around the ball and quickly pulling it to accelerate it. The cord would be connected to the finger holes in the ball to replicate an actual throw. This would act as a starting point for induced force to spin the ball. The sensor could be tested and compared with outside data, while a more consistent approach could be started on the mechanical end.\nPrototype Designs Dice The Dice idea for the Ball Spinner prototype is to design a cube surrounding the bowling ball. The ball will be confined by three motors that will use the friction from the ball to spin it in the three orthogonal directions. This design would allow for decent control of the ball’s primary spin axis since the induced spin occurs from friction. The primary motor will require more power than the other two since it will require more speed.\nTri-Axis Spinner The Tri-axis idea for the Ball Spinner prototype is to use three motor-driven Omni-wheels to simultaneously spin a ball in all three orthogonal directions. The rollers on the Omni-wheels give freedom of movement outside their primary direction, allowing simultaneous rotations. The ball’s primary spin axis has less control due to how tight the Tri-Axis Spinner’s hold on the ball is. The spinner can either have each motor have the same strength or keep one wheel on the primary axis and have it much stronger than the rest. Some potential issues are the device requiring more power or friction to give the ball enough acceleration. Complex Gimbal The Complex Gimbal idea involves a gimbal that rotates with the ball along the primary axis and uses servo motors to adjust the secondary and tertiary axes. A stronger motor would rotate the ball and gimbal. The gimbal will have to be built to handle the load of the ball and the rotational force required to roll the ball.\nAs the project develops, these designs involve building up to four DoFs (Degrees of Freedom). They will start with the primary rotation axis before moving to the secondary and tertiary axes. Horizontal motion will be added if the ball can rotate fast enough in all orthogonal directions.\nSoftware Windows \u0026 Mac application, covered previously\nWe will start small by instructing the hardware to move with respect to only one axis. As the software, the hardware, and the ball spinning system improve, we will implement the ability to instruct the hardware to move with respect to three axes and include more complex physics calculations within the physical instructions to better simulate an actual ball roll.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Design Approach",
    "uri": "/2024-capstone/project-assignments/fall-2024/proposal/design-approach/index.html"
  },
  {
    "content": "Detailed Proposal and Design Document Presentation The Google Slides presentation for the Detailed Proposal and Design assignment can be found here.\n",
    "description": "Information about the Detailed Proposal and Design assignment",
    "tags": null,
    "title": "Detailed Proposal and Design",
    "uri": "/2024-capstone/project-assignments/spring-2024/detailed-proposal-and-design/index.html"
  },
  {
    "content": "Table of Contents Creating a DropletHow to create a DigitalOcean Droplet\nManaging a DropletHow to manage a DigitalOcean droplet\n",
    "description": "Information regarding how to manage DigitalOcean Droplets",
    "tags": null,
    "title": "DigitalOcean Management",
    "uri": "/2024-capstone/how-to-contribute/digitalocean-management/index.html"
  },
  {
    "content": "Overview Docker is a tool used to encapsulate an application and its development enviornment. Rather than transferring the entire application when deploying it to a server, one can simply create a Dockerfile in their project’s directory and specify what to include in the encapsualted enviornment. After testing the Dockerfile to see if it builds and runs successfully, once can then create a “docker-compose.yml” file, specifying the Docker compose format version (not the actual Docker version), project name, build configuration (including where to pull files from and the location of the Dockerfile previously created), Docker container name, ports to listen on, and Docker image name. Once the docker-compose file builds successfully, the build configurations inside of it can be deleted out, and the docker-compose file can be run locally or transferred to a server machine that has docker installed. After running the docker-compose file, the application should be running, and if it is a web application, the user should be able to visit it at the IP address (of the machine running the docker-compose file) and the port specified in the file.\nPrerequisites Before completing any of the following steps, it is necessary to create a Docker account. After creating an account, download Docker Desktop to easily manage containers and images that are created throughout the process below.\nCreating A Dockerfile For An Application To begin the dockerization of an application, a Dockerfile must be created. Open up the development enviornment of the application and create a file named Dockerfile (no extension) in the root directory of the project. The exact layout of a Dockerfile is specific to every project, but can be modified easily to work with any project. A base Dockerfile for a Python application developed in a Linux Ubuntu 20.04 enviornment would look something like the following:\nFROM ubuntu:22.04 COPY . /app RUN make /app CMD python /app/\u003cApplicationName\u003e.pyThe Dockerfile above creates one layer per instruction:\nFROM creates a layer from the ubuntu:22.04 Docker image. COPY adds all of the files (because of the “.” specified) from the Docker client’s current directory. RUN builds the application with make. CMD specifies what startup command to run within the container. When you run an image and generate a container, you add a new writable layer, also called the container layer, on top of the underlying layers. All changes made to the running container, such as writing new files, modifying existing files, and deleting files, are written to this writable container layer.\nRunning The Application Using The Dockerfile Building And Running The Dockerfile After the Dockerfile for the application is created, navigate to the directory in which it was created and enter the following commands:\ndocker build -t \u003cApplicationName\u003e .After building the application using the Dockerfile, go ahead and run the application with:\ndocker run -p 8000:8000 \u003cApplicationName\u003ewhere the numbers after -p are the ports on which the application should run on. The application should now be running on http://localhost:8000 if that port was originally open. If not, try switching what port the application should run on.\nStopping The Dockerfile To stop the application, simply hit CTRL + C to end the execution.\nCreating The Application’s docker-compose File Now that the project’s Dockerfile is configured, built, and successfully running, it is time to create the docker-compose file. In the same location as the Dockerfile created above, create a new file named docker-compose.yml.\nA docker-compose file for the application above would look similar to the following:\nversion: '3' services: \u003cApplicationName\u003e: build: context: . dockerfile: DockerfileIn the docker-compose file above, multiple things take place:\nThe version of the Docker compose format is specified as version 3. A service by the name or the application (indicated by “ApplicationName”) is defined to represent the application. The build context is specified as the current directory where the Dockerfile is located using the context key (\".\") The dockerfile key is set to “Dockerfile”, the name of the Dockerfile to use when building the application. Building The Application After adding the above to the docker-compose file, open a new terminal session and enter the following command to build the application:\ndocker-compose buildCreating A Repository For The Image Once the application is built using the above command, go to DockerHub in a web browser and login to a Docker account. From the dashboard, go to the Repositories tab in the top menu, then hit the “Create Repository” button on the page. To create a new repository for the application, the following fields must be filled out, though the description is optional:\nNamespace - Usually the username of the account, should autofill immediately and can be left as such Repository Name - Can be anything, but it is good practice to name it the same as the application being dockerized Short Description (optional) - Could be anything or left blank Visibility (Public or Private) - Select Public if the image should be available to other Docker users to pull and run locally, Private otherwise Editing The Docker Compose File After an image is created in DockerHub, change the contents of the docker-compose file to the following, either deleting or commenting out the build configuration:\nversion: '3' services: \u003cApplicationName\u003e: image: \u003cNamespace\u003e/\u003cRepositoryName\u003e ports: - 8000:8000In the reconstructed docker-compose file, the build is removed in order to run the application using the file. This time, the file specifies the image location (the one created in DockerHub above) by the Namespace and RepositoryName set in the previous step, along with specifying which desired ports the application should run on.\nSpinning Up The Docker Container Now, go ahead and run the following command to run the docker-compose file:\ndocker-compose upThis command will spin up a Docker container for the application’s image and begin running it on port 8000 of the machine that it is running on.\nStopping The Docker Container After testing the application as much as desired, stop the application with the following command:\ndocker-compose downAfter stopping the application, open the Docker Desktop application and if not already logged in, do so. From the dashboard, navigate to the Images tab on the left side of the screen, and find the image created earlier in DockerHub in the Image menu. To the right of the image’s name (“Namespace/RepositoryName”), there is an Actions tab. Under the Actions tab, click “Show image actions” (three vertical dots), then go ahead and click the “Push to Hub” button. Now, the image created by the docker-compose file is available under the repository created on DockerHub earlier.\nDeploying The Docker Container On Another Machine If the application is meant to be hosted on a different machine, the “docker-compose.yml” file can simply be transferred to the desired machine using any file transfer protocol. However, since only the file needs to be transferred and not the entire application, it is easier just to create another file named “docker-compose.yml” on the desired machine and copy the contents of the most recent version to the new one.\n*Note: Docker must be installed on the destination machine to run the Docker compose file. Depending on what operating system is being used to host the application, DockerDocs has instructions on how to install Docker depending on the user’s OS.\nOnce the Docker engine is installed on the destination machine and the Docker compose file has been created, the file can be run the same way as before:\ndocker-compose upThe above command runs the application but only until the terminal session is closed. Once closed, the Docker runtime is killed off and the application is no longer running. To avoid this, in the event that the goal is to run the application 24/7 (i.e. for a web application), run the Docker compose file in detached mode using -d the same as below:\ndocker-compose up -dIf the container was spun up successfully, the application will continue running after the terminal session is closed.\nTroubleshooting and Informational Commands Below you can find a list of most of the useful troubleshooting and informational commands regarding Docker containers:\nContainer Status To check the status of all Docker containers on a machine, enter the following command:\ndocker statusCheck Which Containers Are Running To check what containers are currently spun up on the machine, use the following command to get a list of them in the terminal:\ndocker psPrinting Container Logs The docker ps command will print out the ID, Image, Command, Created, Status, Ports, and Names fields of each container running.\nIf one wants to check the logs of a specific docker container currently running on the machine, it is easist to run the command above to see the container ID of the specific container that one wants the logs for. Rather than typing in the entire ID into the following command, one only needs to enter the first character of the ID of the container that they wish to view the logs for. For a container with the ID “5a2b3c4d5e6f”, one can just enter the first character, “5”, into the following command:\ndocker logs -f container-idSo after determining the ID of the container one wishes to view the logs for, say container with the ID “5a2b3c4d5e6f”, the command to be run would be:\ndocker logs -f 5In order to only print the last N log items, use the following:\ndocker logs -f container-id --tail NAccessing the SQL Server Use docker ps to determine the container id of the sql server instance.\nUse docker exec to access the terminal of the sql server docker\ndocker exec -it \u003csql-server-container-id\u003e /bin/bashLogin to the sql server using the following:\n/opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P \u003csql password from dockerfile\u003eUse the desired database:\nuse [revmetrix-u]; GOExecute desired sql commands:\nselect * from [User]; GO",
    "description": "Information on how to dockerize a project and deploy onto a separate machine or server",
    "tags": null,
    "title": "Dockerizing an Application",
    "uri": "/2024-capstone/how-to-contribute/dockerizing-an-application/index.html"
  },
  {
    "content": "Project Contributions Created the SmartDot module Contact Information Institution Email: djhake2@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Donald Hake II",
    "uri": "/more/members/donald-hake-ii/index.html"
  },
  {
    "content": "Project Contributions Led initial setup for Simulation team which caused rapid progress early in the project Worked with fellow team member to develop workflows and protocols to make development more efficient Analysed provided project materials (Donald Hake’s proposal and thesis) to guide development Led development of SmartDot Simulator Created file reading cababilities for SmartDot Simulator to allow it to work with test data Created Acceleremoter in the Simulator to allow it to sample acceleration data Created Light Sensor in the Simulator to allow it to sample Light data Worked with fellow member of SmartDot Simulator team to implement a compression algorithm for the acceleration data Programmed a Raspberry Pi to host a Bluetooth Low Energy Server to send data to Mobile App Created series of Powershell/Bash scripts to automatically send acceleration and light sample data to BLE server each time simulator is run Contact Information Institution Email: esam@ycp.edu Phone Number: (717) 515-1038 External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Enoch Sam",
    "uri": "/more/members/enoch-sam/index.html"
  },
  {
    "content": "Overview Below you can find the list of project assignments completed throughout the fall 2023 semester and all of their details.\nList of Assignments Analysis and DesignDesign and Analysis Information and Links to the Document and Slideshow\nProject RequirementsDetails of the project requirements and the associated slideshow\n",
    "description": "A list of all assignments completed throughout the fall 2023 semester",
    "tags": null,
    "title": "Fall 2023",
    "uri": "/2024-capstone/project-assignments/fall-2023/index.html"
  },
  {
    "content": "Overview Below you can find the assignment descriptions for each of the project’s fall 2023 semester milestones. The appropriate slideshow can be seen under each milestone’s title.\nMilestones MS1 - Minimal Working SystemProgress made on the minimal working system and the associated slideshow\nMS2 - 50% Working SystemProgress made on the 50% working system and the associated slideshow\nMS3 - Final Working SystemProgress made on the final working system and the associated slideshow\n",
    "description": "The progress made prior to each project milestone during the fall 2023 semester",
    "tags": null,
    "title": "Fall 2023",
    "uri": "/2024-capstone/project-milestones/fall-2023/index.html"
  },
  {
    "content": "Overview Below you can find the list of project assignments completed throughout the fall 2024 semester and all of their details.\nList of Assignments Analysis and DesignDesign and Analysis Information and Links to the Document and Slideshow\nProposalDesign and Analysis Information and Links to the Document and Slideshow\nRequirementsDesign and Analysis Information and Links to the Document and Slideshow\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Fall 2024",
    "uri": "/2024-capstone/project-assignments/fall-2024/index.html"
  },
  {
    "content": "Overview Below you can find the assignment descriptions for each of the project’s fall 2023 semester milestones. The appropriate slideshow can be seen under each milestone’s title.\nMilestones MS1 - Minimal Working SystemProgress made on the final working system and the associated slideshow\nMS2 - 50% Working SystemProgress made on the final working system and the associated slideshow\nMS3 - Final SystemProgress made on the final working system and the associated slideshow\n",
    "description": "The progress made prior to each project milestone during the fall 2023 semester",
    "tags": null,
    "title": "Fall 2024",
    "uri": "/2024-capstone/project-milestones/fall-2024/index.html"
  },
  {
    "content": "Frontend Team For this milestone, we will have all pages that were previously designed functional. We will also finalize input cleansing for values with the appropriate errors for when they are invalid.\nBackend Team For this final milestone, the interfacing with the backend will be complete. Therefore, all API endpoints will be successfully implemented and will be able to test each endpoint successfully through Insomnia or Postman. We will also integrate these endpoints with the Frontend as much as we can. Automated tests will be implemented for each endpoint to show that all requests are handled correctly. The next task will consist of implementing scripts with instructions to be able to control the motors on all three axes.\nFurthermore, the final system will have all the available data at this point parsed and stored properly whether that is inputted from a .rev file or is collected directly from the sensors, or motors. This means that all simulation data (both actual and expected) will be available for the simulation and the database.\nPart of the final implementation will also be parsing the simulation data from the physical hardware to the simulation in real time, as well as caching the .rev data temporarily where it can be saved locally and/or to the server database. We will also have the previous throw data available for view such that users will be able to see a list of all previous throws, and when a throw is selected, the throw’s data is sent to the simulation where it is reconstructed for view. For locally saved throws, the data will be retrieved from the user selected .rev file after selecting the “Load from File” button. For throws saved server-side, the data will be retrieved from the server through an API request after a user has navigated to the “Load Throws” page.\nCommunication Team A full interface for all of the 9DoF modules referenced previously as SmartDot modules will be implemented for the final working system. The interface will be able to communicate with MetaMotionS, MetaMotionC, SmartDot, and any other modules designated by the client. The Ball Spinner Controller will be able to read data from the gyroscope, accelerometer, magnetometer, and optional light sensor from said modules and send all the data in the proper message structure to the Application. The main point of this functionality (all of which are considered part of the SmartDotAPI) is to provide a layer of abstraction between the physical modules and the software on the application side.\nAt this point in the project, the Application will have full control over all the motors in the Ball Spinner. This means that in the communication aspect, the application can send commands to the Ball Spinner (which will have to be established between the Front End and Back End teams) which will be parsed to send the proper signals to the motor controllers. At the same time, the Ball Spinner will continuously read the data from the auxiliary sensors (as mentioned in the previous milestones) and relay them back to the Front End along with the SmartDot module data for real-time changes to instructions.\nMechanical Team All the orthogonal rotations will be implemented into the system, requiring control and power to be distributed to each axis’s role. Both of the minor axes’ motors will influence the rotation of the bowling ball without removing the control of the ball’s momentum. We will ensure that the motors’ accuracy is satisfactory. Giving control over all the other directions, we would simulate the ball’s horizontal drift across the lane as it rolls.\nAn asymmetric core can cause the ball to wobble, which may affect the primary spin axis. A higher level of accuracy is needed to send proper readings to the controller, which must send appropriate data to be interpreted. Increased degrees of freedom will expose the system to more points of failure. Troubleshooting will be more complex due to more moving parts of the system. As energy is added to secondary and tertiary axes, ensuring energy is not wasted will be a challenge.\nSimulation Team The final working simulation will contain a Three.JS, 3D visualization of the bowling ball traveling down a lane based on the simulation results. The visualization can use either simulation results or actual results from recorded data, there is no functional difference. In this milestone, the simulation will be as accurate as possible.\nExample of how the lane simulation will look inside the application, the user can switch views of the data. ",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Final Working System ",
    "uri": "/2024-capstone/project-assignments/fall-2024/requirements/final-working-system/index.html"
  },
  {
    "content": " Andrew Watkins,Logan Tyran, Patrick Devine Application UML The UML for the front end is very large. Grouped into the highest level abstraction, there is a visualizers group, a views group, and a BallSpinner group. The BallSpinner group is the group that handles the ball spinner connection and distributes data to the visualizers and database. To make the application more open-ended, the ball spinner is interfaced and allows us to provide an alternative implementation for the simulation. The simulation uses the same inputs as the BallSpinner and as a result, serves as a potential point of reference for comparing data. Likewise, we are able to use the IBallSpinner interface to create mock playbacks.\nTo distribute data, there is a DataParser. The DataParser interprets data from the BallSpinner packets and distributes it to those that are listening through actions. Because the BallSpinner group announces the data, there must be listeners. This is where the visualizers group comes in. The visualizers group is a collection of the views that will be implemented for displaying on the screen.\nEvery visualizer is based on a DataViewModel, which implements basic listening functionality to the BallSpinner group’s DataParser. To prevent unnecessary data from going to each visualizer, visualizers have an enum of accepted metrics telling the DataParser what specific data it wants. For example, the LogViewModel will want to receive all forms of data. Additionally, the GraphViewModel may only want to show the X, Y, and Z acceleration.\nLastly, there is the Views group. The application is created using MAUI, and thus a Model-View-ViewModel architecture is in order. Every view or page contains a View, ViewModel, and Model.\nThis group contains almost every page that will be necessary to create the application. For simplicity, the main page of the application will be the output page. Then, when additional data is needed, modals/subwindows will be opened and require the data to be filled in before closing. For example, when opening the application for the first time, the back end will notice there are no login credentials and prompt the user for login info. To close the log in view, the user will have to sign in.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Frontend ",
    "uri": "/2024-capstone/project-assignments/fall-2024/analysis-and-design/frontend/index.html"
  },
  {
    "content": " Theo Bloomquist, Thomas Bywaters, Michael Hensel, John Kettula, Liz Mains Frontend Wireframes Minimal Working System Frontend Team’s role is to create a mobile app that is able to facilitate communication between what is developed by both the Graphics and Backend teams. The minimal working system will consist of an interface that allows for user input and displays user-specific data in response. This will also include the framework for communicating with the Graphics and Backend teams, to be fully implemented later on, this also includes Bluetooth functionality. There will also be camera and camera roll access to later be used to analyze a bowler’s throw.\nIssues Communication between all the moving pieces is a crucial part of the application, however, transmission of graphical data can be incredibly difficult due to its size, which may result in increased latency affecting the user of the mobile application. Along with this, figuring out the specifics of Bluetooth integration will be specific to the output of the chip installed into the bowling ball, meaning it will have to be developed around the hardware-implemented into the chip. Connecting to a device requires specific information to be known, which may be difficult to gather from a simple prototype chip. Bluetooth integration for cross-platform devices is going to be another challenge because Android and iOS have different permission systems.\n50% Working System Implementation of a new user-input interface that allows the user to manage (through creation, deletion, and editing) a list of bowling balls that each have data respective to their real-life values as well as associated Bluetooth IDs. Along with this, enhancements should be made to the communication framework between the mobile application and what is developed by the Backend and Graphics teams to decrease latency and improve end-user experience. Along with this the phone application will have newly implemented functionality that allows for a video to be pulled in from an end-user’s device, this will serve as a proof of concept for further image processing, which will take user video and convert it into positional data.\nIssues Potential issues that we could run into with this milestone are the creation/deletion/editing of a list of bowling balls. The main challenge will be the organization of bowling balls by the user and implementing the local database into the app. This is because the process of adding a bowling ball into the database will span across two communication processes. The first process will be the interaction between the Bluetooth scanner and the app. The second process that will interact with the database is the Maui framework. These two processes combined could cause some issues with the phone app, just in terms of communication.\nFinal Working System For the final working system, we will expand upon the prototype communication to give the app the capability to communicate with the backend servers and implement the Unity visualizers. The app will also be able to display graphical information based on information pulled from the database. To effectively launch the application in a mobile environment, several algorithmic and storage modifications and enhancements will be made to ensure a smooth smartphone experience. A local database will be worked into this design to allow for user data such as usernames, passwords, and bowling balls to be saved locally until the complete server database is established. The groundwork for image processing similar to Dr. Babcock’s Ciclops will also be started for future teams to expand upon. To create a user-friendly app, even in the early production stages, several UI improvements will be made to shift the application away from a testing environment into a user-focused experience.\nIssues Some potential issues that we might run into include the final data size of all of the features we plan to implement. Displaying graphical information and storing graphical information will take up local space. To ensure optimal functionality, the amount of data stored in the mobile app must be minimized. Another issue will be the conversion of the GUI from the Desktop to the Phone. Different features might not make it to both the Phone app and Desktop app. Implementing Ciclops into our app will be another issue in terms of the size of the application. Ciclops is, essentially, another application that will need to work within our application, increasing the app size further. Image processing within Ciclops will be another challenge because it will require the discovery of different imaging algorithms and the discovery of a new framework. More specifically, differentiating between the bowling ball and the background will be a challenge because of all of the different parts of a bowling lane. There’s a potential problem where the bowling ball will blend with other objects.\n",
    "description": "Project requirements specific to the frontend development",
    "tags": null,
    "title": "Frontend Requirements",
    "uri": "/2024-capstone/project-assignments/fall-2023/project-requirements/frontend/index.html"
  },
  {
    "content": " Theo Bloomquist, Thomas Bywaters, Michael Hensel, John Kettula, Liz Mains The frontend will be handling the user interface in the form of a Mobile Application. Data is pulled into the application from the SmartDot API within the bowling ball as well as the Ciclops Program which videos the throw itself. The data from both the SmartDot and Ciclops are processed and pushed into the Local Database. The Local Database will then send the data out to the server. The Unity Visualizer is embedded into the application and is fed data from a specific throw by the Mobile Application.\nThe mobile application gives the user the ability to interact with and utilize the features of RevMetrix. Upon opening, the user is presented with a login screen where they can either sign in to an existing account or create a new one. If the user creates an account, an instance of the User class is created and their chosen username and password is set and stored in the database. If the User already has an account, the entered username and password is verified with those stored in the database, the User class is populated with their data, and they are granted access to the home page. From the homepage, the user has several options. They can view saved bowling balls or add new ones, record a throw using the SmartDot in a saved ball, record a throw video using the Ciclops camera, or view previous throws as video or SmartDot data.\nSmartDot API The SmartDot API will facilitate communication between the mobile app and the SmartDot inside the user’s bowling ball. Using Bluetooth LE, the user will connect to a SmartDot and, after signaling the SmartDot to start, may begin recording their throw. Users will have to first scan for and select a SmartDot using bluetooth. Upon first connection, a new ball will be created for them as an instance of the Ball class. Saved bowling balls will remember their SmartDot’s bluetooth ID to allow for instant connection. While the ball is in motion during the throw, the SmartDot will transmit data back to the mobile app that will store it in an instance of the Throw class to be referenced later. Recording of data stops when the ball reaches the end of the lane or when the user signals so from the app.\nFile Reader The File Reader will allow the user to import video files into the desktop application, so that it can then be analyzed by Ciclops, which will extract bowling statistics from the video. A potential application of the file reader could also be writing local files to the local device. The File Reader could also be manipulated to generate files based on the data received from the SmartDot API. The File Reader is implemented within the application and is able to transmit data across the application using local variables \u0026 the local database.\nCiclops An implementation of Ciclops will be another feature in the app that will analyze a bowler’s throw and extract data from it. It will use image recognition algorithms to differentiate between the bowling ball and the bowling lane. It will use each individual frame and compare it to the next frame to get varying statistics about the ball. These statistics include: speed, velocity, and curve. This information will be incredibly useful for extrapolation to calculate the metrics that will be eventually served to the user. Ciclops will be implemented directly in the application and will store information directly onto the applications local database.\nMobile Application User Interface All Frontend UI will be implemented using XAML backed with C#, allowing for users to view outputted, processed data that is displayed onto the screen using dynamically allocated XAML text Label classes, as well as allowing for users to input textual information \u0026 click buttons. Button Classes come standard with XAML applications, their specific function is to handle “Clicked” input from the user, when “Clicked” is triggered by the user clicking a button a function defined in the XAML.CS class is executed. This level of abstraction allows for buttons to have dynamic functionality, meaning that whatever functionality is provided by one button to the user could be entirely different from the functionality provided by another button to the user. Textual input displayed on the XAML page can be handled in one of two ways, “TextChanged” \u0026 “Completed”. “TextChanged” is triggered when any text within the input field is changed and, runs similarly to “Clicked” as it, it runs a function that is defined with the XAML.CS class. “Completed” functions similarly to “TextChanged,” triggering a specified event when the Enter key (Tab on Windows) is clicked. Dynamic output that is viewed by the user is handled by variables defined within the XAML.CS classes; these variables are passed from the XAML.CS class to the XAML output field (usually a text Label class) through the use of Binding Paths. Binding Paths are used by XAML classes to reference data, such as variables, that are defined and allocated by XAML.CS classes, Binding Paths access the current value of this data and are then displayed to the user by the Label class. Navigation between pages is handled by both the PushAsync and GoToAsync function that takes the String name of a pre-existing XAML \u0026 XAML.CS class that defines the structure of a page that will be pushed onto the stack to be displayed to the user.\nClass Methods SmartDot API ScanAsync() ConnectToDeviceAsync() ConnectToKnownDeviceAsync(Guid) ReadAsync() ReadServicesAsync() ReadCharacteristicsAsync() ReadDescriptorsAsync() DisconnectAsync() File Reader MakeFile(string fileName) WriteFile(string fileName, string text) Create(string fileName) Ciclops TakePhoto() OnTakeVidBtnClicked(object sender, EventArgs e) Mobile Application User Interface Clicked(object sender, EventArgs e) TextChanged(object sender, TextChangedEventArgs e) Completed(object sender, EventArgs e) PushAsync(String page) GoToAsync(String page) User Login(string, string) CreateAcct(string, string) AddBall(IDevice) NewGame() DeleteBall(Ball) DeleteGame(Game) Game AddThrow() DeleteThrow(Throw) UML Diagram MVC Architecture Due to the design architecture of .NET MAUI, both the XAML \u0026 XAML.CS classes can be considered the “controller” classes as they both handle data flow to each other. However the specific definitions of the UI are clearly handled by the XAML class and the model for which outputted data is structured is handled by the XAML.CS class. While this may be difficult to grasp at first, there are sections of code within both the XAML and XAML.CS classes that handle \u0026 execute control logic amongst themselves, making these sections both the respective ‘Controller’ of this diagram.\nLocal Testing Database Schema The primary purpose of the local database that is hosted by the frontend application is to temporarily store user information so that it can be transmitted via Web API to the backends Cloud infrastructure for long-term storage. The backend team will be handling the creation of this local database, while we will create a dummy database purely for testing purposes. This is to allow for the frontend team to retrieve data to ensure the functionality of application features. As seen above, the schema of this database is almost identical to the schema of the backend team’s local database as they will be storing similar information. The main difference being the User Table which will be used for testing users while the server databases are being built. This dummy database is also to ensure seamless integration between the frontend and backend team when they eventually come together to combine their systems.\n",
    "description": "Project Analysis and Design specific to the frontend team",
    "tags": null,
    "title": "Frontend Team",
    "uri": "/2024-capstone/project-assignments/fall-2023/analysis-and-design/frontend/index.html"
  },
  {
    "content": "Challenges Frontend In our project, the frontend challenges primarily revolve around generating physical instructions for the hardware. This challenge becomes increasingly complex as we incorporate multiple axes and different core types into the prototype. Additionally, establishing a reliable interface with the SmartDot hardware via Bluetooth Low Energy (BLE) poses its own difficulties, especially when collecting live data from the accelerometer, gyroscope, and ambient light sensor during simulated runs.\nBackend Some backend challenges might include setting up a local database in a Docker container, which can involve compatibility issues. Additionally, updating the database schema and configuring API endpoints for data retrieval and updates can be complex. This can further on develop into a greater challenge when handling version control to ensure a smooth API interaction with the database.\nBall Spinner One difficulty that may arise, is the ability to accurately send readings from the Ball Spinner to the rest of the system. It is vital as the feedback would impact both the motor controller and the back end software. Next, emulating the same amount of torque that a human would apply to the bowling ball requires significant power. For our motors to produce such torque in such limited time it may require an energy storage device to release such power all at once. We need to ensure that the Ball Spinner does not destroy itself, or the rest of the system. The Ball Spinner needs to have a level of robustness to endure the weight of the bowling ball as well as spinning the ball in different axes. Preserving the momentum of the ball while still accelerating would be another challenge to face. Accelerating the ball along multiple axes accurately and consistently at different speeds is another difficulty to face. The constructability of the Ball Spinner is a factor that we must consider as this affects the design we ultimately decide on. Our time constraints limits the overall scope of our designs.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Future Implementations",
    "uri": "/2024-capstone/project-assignments/fall-2024/proposal/future-implementations/index.html"
  },
  {
    "content": "Ball Spinner mechanism will control the ball in 3 orthogonal directions\nBall Spinner will interface with 9DoF module (either SmartDot or MbientLabs) to read output from Gyroscope, Magnetometer, Accelerometer, and Light sensor.\nApplication can read and send data to the Ball Spinner to control motors and the movement of ball\nData created from the Ball Sinner and SmartDot sensors will be stored in a secure database\nData from previous sessions will be accessible to the user based on account credentials\nUser can only input valid parameters that control the Ball Spinner\nUser can save data from session to a .rev file\nUser can load saved data from previous session\nApplication will display the graphical orientation of the ball while Ball Sinner is in motion\nGraphs will be drawn to display expected data and real-time output data from SmartDot\nThe ball located within the Ball Spinner will move based on physics calculations from the user input parameters.\nUser will be able to access simulation once Ball Spinner has finished movement.\nGraphical simulation will take data from Ball Spinner and SmartDot modules and display virtual expectations of the ball moving down an actual lane.\nAutomated testing of system\nUser can focus on specific graph/result\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "General Project Requirements",
    "uri": "/2024-capstone/project-assignments/fall-2024/requirements/general-project-requirments/index.html"
  },
  {
    "content": "User makes an account for the application Precondition\nUser has opened the Application\rUser has opened the login popup\rMSS - Main Success Scenario:\nUser populates the username, password, and re-enter password fields\rUser selects the final register button\rApplication checks if all required fields are filled and meets other requirements\rLogin popup will display a message that the user has successfully registered\rExtensions:\n3a. Username already exists in the application Application displays error message that states “Username already exists”\rUser can modify username (return to MSS #1)\r3b. Password is not strong enough\rApplication displays error message stating “Password must contain 1 capital, 1 lowercase, and 1 special character\"\rUser can modify password (return to MSS #1)”\r3c. Username is not long enough\rApplication displays error message stating “Username must be 8 characters long”\rUser can modify password (return to MSS #1)”\r3d. Password is not long enough\rApplication displays error message stating “Password must be 8 characters long”\rUser can modify password (return to MSS #1)”\rUser logs in to application Precondition:\nUser has opened the Application\rUser has opened the login popup\rUser is not already logged in\rMSS - Main Success Scenario:\nUser enters login details\rUser clicks “Login” Button\rThe application checks the provided username and password against the database.\rApplication authenticates the user and closes the login popup\rThe logout button in the dropdown menu is replaced with logout\rExtensions:\n5a. Incorrect login information\rApplication displays an error message stating that the username or password is incorrect\rUser can reinput log in details (return to MSS #3)\r5b. Forgot Password:\rUser button labeled “Forgot Password” Application prompts the user to enter their email and additional fields\rUser resets the password and returns to the login screen (return to MSS #3)\rUser Views Previous Throws From Database Precondition:\nThe user is logged in\rUser has navigated to the “Load Throws” page.\rMSS - Main Success Scenario:\nA connection is made with the database to retrieve a list of all the user’s stored throws\rApplication displays a table of all of their previous spins, showing the date, time, and name of each throw for each session data.\rUser selects a simulated session from the list.\rA request is made to the local server to retrieve the data stored for the selected session.\rUser selects Load Data button\rUser is shown a reconstruction from the simulation using the data stored in the database along with the actual and expected output from that session.\rExtensions:\n1a. Error occurs with database\rA message is displayed stating “An error has occurred”\rThe user is redirected to the “Main Output” page\r5a User selects “Load Parameters”\rUser is redirected to “Throw Page” with parameters from loaded session already input\rUser Views Previous Throws From Local File Precondition:\nUser has navigated to the “Main Output” page. MSS - Main Success Scenario:\nUser selects “Load From File” Button\rSystem opens File Directory that filters for only files with “.rev” extension\rUser Selects file\rApplication parses file into respective Graph Data\rGraph Data is Displayed in Graph Locations of Main Output Page\rExtensions\n3a User Selects file without “.rev” extension\rError Popup Appears saying “Unable to Read File”\rUser Selects “Close”\rPopup Closes and sends user to “Main Output Page” User Uploads a Throw From Local File to Database Precondition:\nUser is logged in\rUser has navigated to the “Cloud Management” page. A connection has been successfully established with the database\rMSS - Main Success Scenario:\nUser selects “Upload” Button\rSystem opens File Directory that filters for only files with “.rev” extension User Selects file\rApplication pushes file to database\rMessages conveys that upload was successful\rExtensions:\n3a. The user closes the File Directory\rThe application returns to the “Cloud Management”\rUser Deletes Previous Simulated Throws Precondition:\nThe user is logged in\rUser has navigated to the “Previous Throws” page.\rUser has successfully connected to the databases\rUser has previous session data stored MSS - Main Success Scenario:\nUser selects the trash can next to the previous session data that the user wants to delete\rA popup is displayed asking the user to confirm that they want to delete specified data\rUser selects “Delete Data” button in popup window\rApplication determines which database the deleted session data is stored in and requests for data to be deleted\rUser is display a table of all of their previous sessions still stored in the Databases\rExtensions:\n3a User Selects “Cancel” button in popup Window\rPopup window is closed User can select other previous session data they would like to delete (return to MSS #1)\r4a Error Deleting Data\rPopup window appears display that an error had occurred when deleting from database and to try again later\rUser selects “OK” on Popup\rPopup window is closed User is display a table of all of their previous sessions stored inDatabases (return to MSS #1)\rUser Connects to the BallSpinner Precondition: User has navigated to the “Input” page. MSS - Main Success Scenario: User selects the “Connect to Ball Spinner” button Popup is displayed with a drop-down menu of all active USB ports User selects the USB port that the Ball Spinner is connected to User clicks “Connect” button System establishes a connection to the BallSpinner Popup is closed with “Connect to Ball Spinner” button changed to “Ball Spinner Connected” label Extensions: 5a. Connection Failure Application displays an error message specifying that the connection was unsuccessful User can re-select USB port and retry connection (return to MSS #2)\nUser Connects To The Ball Spinner MSS - Main Success Scenario: User Selects the “Connect To Communications Device” button Popup is displayed with a drop-down menu of all active USB ports User Selects the USB port with a communication device Application attempts to establish communication with the communication device Communication device confirms connection to the Application Popup displays the device has been connected User closes the menu Extensions 3a. No communication devices available to connect Message notes no available devices 4/5a. Communication between the application and device are unsuccessful Message notes connection failure (return to MSS #3)\nUser Inputs Parameters to Control Ball Movement Precondition: BallSpinner is connected to the device SmartDot module is connected to the device User has navigated to the Inputs page\nMSS - Main Success Scenario: Application prompts user to enter different parameters to control the BallSpinner User inputs values for the parameters User clicks on the “Run” button Application validates the values inputted Application sends the input parameters to the controller to calculate the ball’s movement Controller interfaces with the hardware’s motors to correctly move the ball based on the calculations The ball moves based on the input parameters The SmartDot sensors send real-time data to Simulation, which interprets the data from each sensor to create an actual 3D projection for the ball and show a data plot for each sensor. Will see the Displays trajectory and speed of the ball. When putting in the data you will be able to control the location and curvature of the ball. The application updates the 3D Viewport to reflect the ball’s new position and rotation\nExtensions: 1a: Users has selected a cloud initial value load Application parses file into respective input fields (continue to MSS #3) 2a: Users selects local initial value load System opens File Directory that filters for only files with “.rev” extension User Selects file Application parses file into respective input fields (continue to MSS #3) 4a: Input parameters are invalid The application alerts the user that the input parameters are invalid User can reenter the input parameters (return to MSS #2) 6a: Connection error with the ball spinner: The application alerts the user that the connection was lost and includes different ways to help with the connection Was the BallSpinner connected? Is the ball spinner on?\nUser can reenter values once (return to MSS #1)\nUser Views Live 3D simulation and Graphical Analytics of Ball’s Expected and Actual Movement Precondition: User has successfully input all necessary parameters and passed them to the ball spinner. User has established a successful connection with the Ball Spinner and Raspberry Pi. MSS - Main Success Scenario The Ball Spinner controller sends sensor data to the simulation component running on the application before it begins to spin the ball. The simulation uses this data to show the expected 3D projection of the ball and interpret the orientation, location, and speed of the ball as it goes down lane. The Ball Spinner controller sends the SmartDot’s real time data to the Simulation, which interprets the data from each sensor to create an actual 3D projection for the ball and show a data plot for each sensor. Simulation and graphs are displayed to user in real time Extensions: 1a. An error occurs while connected to Ball Spinner An Error Popup will relaying to User that an error had occur\nUser Saves the Result of the Ball Spinner’s Movement Precondition The user has already run a simulation User is on the output page MSS - Main Success Scenario User Clicks the “Save” button on the results page System opens File Directory to save a file with a “.rev” extension The user names and saves the file Extensions: 3a. The User closes the File Directory The application returns to the output page\nUser Terminates the Simulation Precondition: The user has successfully begun a simulated run with the ball spinner, and the ball spinner is actively in motion and data is being sent back to the device. User is currently viewing the live simulation page. MSS - Main Success Scenario: User selects the “End Simulation” button at the bottom of the simulation page. The application sends a signal to the ball spinner controller and the SmartDot device to let them know the simulation has been canceled. The ball spinner controller ceases its communication with the motors. The application deletes all cached data from the canceled simulated run.\nUser Views documentation/help Precondition: The user has opened the application MSS - Main Success Scenario User selects the Help button The system opens the Rev-Metrix Wiki in the default browser\nUser logs out Precondition: The user is logged in MSS - Main Success Scenario User opens account drop-down and selects log out User is logged out Application prompts user to the login screen\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "General Project Requirements",
    "uri": "/2024-capstone/project-assignments/fall-2024/requirements/use-cases/index.html"
  },
  {
    "content": "Table of Contents BLE To communicate with the SmartDot and simulator, the RevMetrix app utilizes Bluetooth Low Energy (BLE). This is essentially bluetooth for low-power objects like smartphones, smartwatches, or sensors. Communication between BLE devices works on a client-server structure known as GATT (Generic ATTribute profile). The app and similar devices are GATT clients which can send and request data from connectable devices known as GATT servers. The GATT server can receive messages from the client and holds data for the client to read. This data is nested in characteristics inside of services which are a part of the GATT server’s profile. By knowing the UUIDs of the device, service, and characteristic, communication can be established.\nDotnet-bluetooth-le For in app BLE communication, we use the simple dotnet-bluetooth-leplugin. This plugin can be downloaded as a nuget package in your IDE and provides the basic functions for scanning, connecting, and communicating with other BLE-enabled devices. To fully utilize the necessary BLE functions several interfaces in the plugin must be invoked. They can be read about in the official documentation, but the basics can be gathered here.\nIBluetoothLE This must be invoked solely to utilize bluetooth functions on your device\rIAdapter This must be used to discover and connect to other devices. Discovery is done through scanning which will add discovered devices to a List. Devices are of the IDevice type and can be connected to with functions in IAdapter.\nIDevice This is the type for any connected device and includes information on the connected device such as the name, UUID, and connection state. An IDevice object also functions for the client to read from its available services.\nIService This is the type for BLE services read from a device. While services do not usually contain the data you will use, they organize the GATT server’s information and contain information about the data in their characteristics.\nCharacteristic This is the type of characteristics which will hold the meaningful data to be read or written to. Once a characteristic is discovered, information can be gathered from it. This data will be received as an array of bytes, but can also be automatically converted into a string if applicable.\nWhile this is just the general information on each of th4ese interfaces, specific functions and information can be read on the plugin documentation page or in the interface files themselves.\nMetaWear - MMC/MMS Communications To simulate SmartDot communication with real devices, MbientLab’s MMC and MMS sensor modules are used. These small devices are fitted with various sensors used for recording acceleration, gyroscope, light, and magnetometer data. More about the modules themselves can be read on MbientLab’s website. We can communicate with these sensors over BLE from the app. Once the correct services and characteristics are discovered, commands can be sent to initiate recording on the sensors and data can be read back in real time. MbientLab has an official interface to communicate with the sensors known as MetaWear. Though we do not use the full interface, its github pages contain useful information for understanding basic communication with the MMS/MMC.\nByte Arrays Information is read from and commands are sent to the MMS/MMC in the form of byte arrays. Commands sent will always need to start with the identifier byte for the sensor you are trying to communicate with. This data can be found in the github pages, but for convenience: accelerometer = 3, ambient light sensor = 20, gyroscope = 19, and magnetometer = 21. Byte arrays read from the sensor will always begin with 2 header bytes, the first being the identifier byte for the sensor the data is coming from. The remaining bytes after the first 2 will need to be converted into decimal values. When writing to MMS/MMC certain configuration commands must be sent before starting and after stopping, these vary between sensors and will be elaborated on below.\nAccelerometer: 3 When communicating with the accelerometer, the Output Data rate (ODR) and data range must be set. Currently for RevMetrix, these are set to 200 Hz and 16 Gs respectively. The accelerometer must also be set to sampling mode to properly receive the data. A subscription command must also be sent to receive the accelerometer data when it is ready. Once configured, the accelerometer can be started by writing the byte array {3, 1, 1} to the MMS/MMC. The accelerometer can then be stopped with the byte array command {3, 1, 0}. After stopping the sensor, the configuration must also be disabled. When reading the accelerometer data, after the first 2 header bytes, the remaining 6 must be broken into pairs and converted to floats representing X, Y, and Z values. Each of these values must then be further converted with the function below n = (n/32768.0f)*data range\nAmbient Light: 20 When configuring the light sensor, the gain, integration time, and measurement time must first be set. The gain values control how much ambient light should be filtered out when recording and the measurement and integration times control how fast the data is received. The light sensor also requires a subscription command like the accelerometer. The light sensor can then be started and stopped with the commands {20, 1, 1} and {20, 1, 0} respectively. Like the accelerometer, the configuration must be disabled after recording. The data for the light sensor must be converted from the byte array into a Lux value. This involves splitting the byte array into channels, generating a ratio from these channels, and using that ratio to decide how to convert the data. This segment of code for conversion can be found in the RevMetrix app in the ScanPage.xaml.cs file.\nGyroscope: 19 The gyroscope works very similarly to the accelerometer. The ODR and data range must first be configured. The app currently uses 200 Hz and 250 dps for the ODR and data range. Like the accelerometer, commands must be sent to enable data sampling and subscribe to the gyroscope sensor. The gyroscope can then be started and stopped with the commands {19, 1, 1} and {19, 1, 0} respectively. Once again, the configuration must be disabled after. The data for the gyroscope can then be converted using the same equation as the accelerometer data. The data range values for the gyroscope correspond to equal accelerometer values. For 250 dps, the equivalent range to be used in the equation would be 2.0f.\nMagnetometer: 21 The magnetometer has yet to be implemented, but will communicate in a similar fashion to the accelerometer and gyroscope. Information on magnetometer communication can be found in the MetaWear Github pages.\nThe full configuration commands for all the implemented sensors can be found in ScanPage.xaml.cs file of the Revmetrix app. For other configurations and more context on how to communicate with the sensors, the test files of the MetaWear SDK can offer assistance.\nThe MMS/MMC can be used either through the MetaWear app or the RevMetrix app. To use the MMS/MMC in the RevMetrix app, you must navigate to the Scan Page. This page is where most of the experimentation with bluetooth is compiled. This page can be accessed from the ball arsenal page in the bluetooth page by clicking “connect to a new device.” From here you can either scan and find a device named MetaWear using the check button or connect automatically to the MMS/MMC with the associated buttons. These buttons are linked with the UUIDs of specific modules, so make sure you use the right ones. They will hopefully be marked. Once connected as indicated in the top right corner of the screen, simply click the “Start/Stop Sensors” button and the module will begin recording. Simply click the button again to stop it and you will be taken to view the graphs.\rData Graphing\nLiveCharts2 is a cross-platform graphing package capable of turning data sets into organized graphs. These graphs are very user friendly and offer a range of customization options. Data in graphs must first be included in a Series object which the graph object in the view can reference. Livecharts requires projects using it to register with SkiaSharp, a parent graphing package, but is completely free outside of that registration.\rData is graphed using the LiveCharts2 nuget package. This package makes graphing data easy by linking instances of a Series class to an object in the connected XAML file. For this app, the sensor data is read from a csv file which was written to during recording and added to the Series’ Values property. Functions for interacting with these Series objects to affect the graphs in the app can be found in the graphtest.xaml.cs file. More can also be learned about how to create these graphs on the LiveCharts website.\nSimulator Communication The simulator utilizes a Raspberry Pi as a GATT server to transmit data to the app just as the SmartDot would. To communicate with the simulator from the app, from the home page, click the “View Simulator” button. This will take you to the simulator communication page. The “Connect to Sim” button should automatically connect you to the Pi. Make sure the Pi is active before attempting to connect. Even if the Pi is active, it may take time to establish a connection. Once the app connects to the PI, a message will display in the top right corner. From this point, all you will need to do is click the “Read Data” button and the simulator data will read out into the app.\n",
    "description": "Information regarding setting up your development enviroment",
    "tags": null,
    "title": "Getting Started",
    "uri": "/2024-capstone/how-to-contribute/bluetooth/index.html"
  },
  {
    "content": "Table of Contents BackendHow to setup your development environment for the backend\nCiclopesHow to setup your environment to develop the Ciclopes\nMobile ApplicationHow to setup your development environment for the mobile app\nSmartDot SimulatorHow to setup your environment to develop the SmartDot Simulator\nVisualizerHow to setup your environment to develop the Visualizer\n",
    "description": "Information regarding setting up your development enviroment",
    "tags": null,
    "title": "Getting Started",
    "uri": "/2024-capstone/how-to-contribute/getting-started/index.html"
  },
  {
    "content": "Development Enviornment The preferred development enviornment for the Cloud-Infrastructure .NET solution is Microsoft Visual Studio 2022 Community Edition. When installing Visual Studio, make sure to install all of the options checked below:\nAfter installing Visual Studio, you will also need to install SQL Server Developer Edition (Free). All of the default installation settings can be followed for this. Finally, you’ll need to install SQL Server Management Studio. The default installation options for SSMS can be followed here also.\nCloning The Repository To clone the Cloud-Infrastructure repository, head over to the GitHub Repository, click the green “Code” dropdown on the repo page, then copy the https link given from the dropdown, as seen below:\nAfter copying the repo link, open Visual Studio and click \"\" on the start page as seen here:\nFrom here you will be prompted to enter the link of the repository to clone and the path at which to create the directory of the repo on your machine. Go ahead and paste the repository link and choose where to save it, then hit the “clone” button in the bottom right as seen below:\nNow that the repo has been cloned, Go ahead and click on the configuration manager next to the run button. Next, ensure that the “Server: https” configuration is selected and then hit run.\nLastly, the Swagger website will open up locally and will contain of all the API endpoints. Taaa daaa\nEverything from here on is basic source control practice. If you are unfamiliar with these practices, check out the Git Cheat Sheet for an introduction to them!\n",
    "description": "How to create a branch of the cloud-infrastructure repository and make edits",
    "tags": null,
    "title": "GitHub Workflow - Backend",
    "uri": "/2024-capstone/how-to-contribute/github-workflows/backend-workflow/index.html"
  },
  {
    "content": "Prerequisites Most of these instructions at JetBrains Rider specific, as that is what we are using to develop the Frontend Application.\nCreating an Issue Go to the Frontend Github repository, using the following link: https://github.com/YCP-Rev-Metrix/FrontEnd/tree/master\nWithin this page click on the Issues tab, which should be found in the following location: After your screen has refreshed, you should see a screen similar to the following screen below. After this has been done select New Issue: Give the issue a name and a description, and make sure to click Assign Yourself under the Assignees tab. After this is done, assign the issue a Label that is corresponding to whatever you are trying to implement (whether it’s patching a bug or adding new functionality) and click Submit New Issue. This issue will eventually be connected with a branch but this can’t happen until that branch is created so onto our next topic:\nCreating a Branch Run the following commands within a terminal window:\ngit checkout -b {name of branch} \u003c- creates branch locally\nEx:\ngit checkout -b 8-update-gitignore\ngit push origin {branch name}\nThis branch will now show up on the Github repo on the website GUI, to ensure this branch is up to date with the master run the following commands within the same terminal:\ngit fetch\ngit merge origin/master\nOnce this is done be sure to associate the branch to an issue\nLinking an issue to a branch Within the Issues tab click on the issue you previously created and click the gear next to the Development section on the right side. After clicking this gear, traverse through the Github repository and select your newly created branch. This will allow you to close this issue once this branch has been PR’d into the master, as the branch should also then be deleted to create a new branch to tackle the next issue. -Basically a branch is a temporary work space rather than a permanent one -Create an issue-\u003emake a branch for it-\u003eCode a bunch-\u003ePR-\u003edelete-\u003erepeat\nCreating a Pull Request Select the Commit section found in the top left section of the Rider tab, shown below: Select the files you would like to Commit (Found in Unversioned Files) and check their boxes. DO NOT commit .gitignore. Once they’ve been selected press Commit and Push… (If you selected Commit you must follow the instructions specified in {Section B} before trying to make a PR if you selected Commit and Push… feel free to ignore them)\nAfter the changes have been Pushed to the remote branch, go to the Github repository website and you should see something like this: If you select Compare \u0026 pull request Github will automatically generate you a Pull Request that will pull your branch into master.\nOnce the pull request has been accepted and merged into master, delete your branch \u0026 issue as specified below.\n{Section B} If you selected “Commit” you must follow these instructions before attempting to make a PR Click on the Git button found in the bottom left section of the tab, shown below: Once that has been opened, right-click on the Local branch that you’ve been working on (in this example it’s 18-Screentoscreen underneath the Local section) and select Push…\nOnce your Local branch has been pushed to the Remote, the Remote branch will have all the changes that you have coded on your device and a Pull Request can be made.\nDeleting a Branch Input these commands into your terminal:\ngit branch -d {branchname} \u003c- deletes branch locally\ngit push origin --delete {branchname} \u003c- deletes branch remotely\n",
    "description": "How to create a branch of the frontend repository and make edits",
    "tags": null,
    "title": "GitHub Workflow - Frontend",
    "uri": "/2024-capstone/how-to-contribute/github-workflows/frontend-workflow/index.html"
  },
  {
    "content": "Making General Changes Swap the current Github branch to the Test branch: Click on the “Fetch Origin” button for the Test branch: Proceed to make the necessary changes for the Github Issue you are working on Review your changes in Github Desktop: Swap to your personal branch and bring the new changes over Include Github Issue # in the commit subject (i.e. Issue #12, new pin model) Commit your changes Go to the Github repository’s website and hit the New Pull Request button Make sure that your source and destination are both correct before creating the pull request This is (test \u003c– yourUsername) almost always Create pull request, then copy the link into the PR and send to Discord Make sure to tag the @Graphics Dev Team Approving Git Pull Requests Either check the current pull request on Github.com or click the link in Discord Open the Files Changed tab to review changes made Review changes, and if everything checks out, approve and submit review ",
    "description": "How to create a branch of the simulation repository Test branch and make edits",
    "tags": null,
    "title": "GitHub Workflow - Simulation",
    "uri": "/2024-capstone/how-to-contribute/github-workflows/simulation-workflow/index.html"
  },
  {
    "content": "Table of Contents GitHub Workflow - BackendHow to create a branch of the cloud-infrastructure repository and make edits\nGitHub Workflow - FrontendHow to create a branch of the frontend repository and make edits\nGitHub Workflow - SimulationHow to create a branch of the simulation repository Test branch and make edits\n",
    "description": "All GitHub workflows for the project",
    "tags": null,
    "title": "GitHub Workflows",
    "uri": "/2024-capstone/how-to-contribute/github-workflows/index.html"
  },
  {
    "content": "Table of Contents Continuous Integration/DeploymentInformation about the project's CI/CD workflows\nContributing DocumentationHow to add, edit, and remove documentation on the Wiki\nDigitalOcean ManagementInformation regarding how to manage DigitalOcean Droplets\nDockerizing an ApplicationInformation on how to dockerize a project and deploy onto a separate machine or server\nGetting StartedInformation regarding setting up your development enviroment\nGetting StartedInformation regarding setting up your development enviroment\nGitHub WorkflowsAll GitHub workflows for the project\nLinking DomainsHow to link domains to an application using DNS records and Nginx Proxy Manager\nRevMetrix WebAPIInformation on how to use the WebAPI\n",
    "description": "",
    "tags": null,
    "title": "How To Contribute",
    "uri": "/2024-capstone/how-to-contribute/index.html"
  },
  {
    "content": "Project Contributions Ball Curve Functionality Realistic Physics Implementation Interpolation Scripts Contact Information Email: ianjviveiros@gmail.com Phone Number: (484) 388-9651 External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Ian Viveiros",
    "uri": "/more/members/ian-viveiros/index.html"
  },
  {
    "content": "Original System Architecture Backend - Database ArchitectureUML diagrams representing the initial database architecture and schemas\nPhone App - Proof of ConceptDrawing board ideas for the layout and interaction methods of the phone application\nSimulation - First ThoughtsThe base ideas around using Unity for the development of a bowling simulation\n",
    "description": "",
    "tags": null,
    "title": "Initial Project Ideas",
    "uri": "/2024-capstone/initial-project-ideas/index.html"
  },
  {
    "content": "The ISmartDot interface will allow a layer of abstraction between the Application and the SmartDot or SmartDotSimulator.\nThe sole function of this interface is to allow reading and writing from pages of memory stored on the SmartDot, and make / maintain connections to the SmartDot hardware.\nISmartDot interface /** * Interface representing the basic functionality of the Bluetooth connection between the mobile * application and a SmartDot implementation (Simulator \u0026 Hardware) */ public interface ISmartDot { /** * Summary: Attempts to create a connection to the SmartDot hardware * Params: connectionParameters * Returns: Version representing the SmartDot hardware version (APIs use), null * if unable to connect */ public Task\u003cVersion?\u003e Connect(ConnectionParameters connectionParameters); /** * Summary: Tests if the connection to the SmartDot hardware is present * Params: connectionParameters * Returns: Boolean representing if there is a connection to SmartDot hardware */ public Task\u003cbool\u003e IsConnected(); /** * Summary: Asynchronous method to write one page to the SmartDot implementation * Params: address -\u003e The page start addess in memory * buffer -\u003e Data (byte[]) to write to the SmartDot implementations page * bytes -\u003e Length of data to write from * Returns: A bool representing if call was successful */ public Task\u003cSmartDotTransactionResult\u003e WriteBytes(long address, byte[] buffer, long bytes); /** * Summary: Asynchronous method to read one page from the SmartDot implementation * Params: address -\u003e The page start addess in memory * buffer -\u003e Ref data (byte[]) read from the SmartDot implementations page (will attempt to fill completely) * bytes -\u003e Length of data to read into * Returns: A bool representing if call was successful */ public Task\u003cSmartDotTransactionResult\u003e ReadBytes(long address, ref byte[] buffer, long bytes); /** * Summary: Sends a command to the SmartDot hardware * Params: command -\u003e The string command to send to the SmartDot hardware * Returns: Result from the command execution on the SmartDot hardware */ public Task\u003cstring\u003e OutgoingSmartDotCommand(string command); /** * Summary: Invokes IncomingSmartDotCommandCallback method. Should be executed only from the * implementor. * Params: command -\u003e String command called from SmartDot hardware * Returns: n/a */ protected virtual void RaiseIncomingSmartDotCommand(string command) =\u003e IncomingSmartDotCommandCallback?.Invoke(command); /** * Summary: Incoming command callback (from SmartDot hardware). Signals from the SmartDot hardware * that something important happened. * Params: none * Returns: n/a */ public Action\u003cstring\u003e? IncomingSmartDotCommandCallback { get; set; } }SmartDotTransactionResult enumeration /** * Enum representing the transaction result state of a communication with SmartDot hardware */ public enum SmartDotTransactionResult : byte { /** * SmartDot transaction succeeded */ SUCCESS, /** * SmartDot transaction failed - unknown cause */ FAILURE_UNKNOWN, /** * SmartDot transaction failed - data corruption */ FAILURE_PERMISSION_ERROR, /** * SmartDot transaction failed - device disconnected */ FAILURE_DISCONNECTED, /** * SmartDot transaction failed - data corruption */ FAILURE_DATA_CORRUPTION }ConnectionParameters class /** * Parameters necessary to successfully connect to the correct SmartDot hardware */ public class ConnectionParameters { }The SmartDotAPI will be responsible for interpreting data sent and received from an ISmartDot interface implementor by accessing the version # on the first memory page.\n",
    "description": "Information about the ISmartDot interface",
    "tags": null,
    "title": "ISmartDot Interface",
    "uri": "/smartdot/ismartdot/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "James Devine",
    "uri": "/more/members/james-devine/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: jkettula@ycp.edu Phone Number: (240) 285-7449 External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "John Kettula",
    "uri": "/more/members/john-kettula/index.html"
  },
  {
    "content": "Project Contributions SQL Server Database Development WebAPI development Contact Information Institution Email: jcarvell@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Jordan Carvell",
    "uri": "/more/members/jordan-carvell/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Kyle Franhauser",
    "uri": "/more/members/kyle-franhauser/index.html"
  },
  {
    "content": "Overview To link a domain to an application running on the DigitalOcean Droplet, it is best practice to do so using Nginx Proxy Manager. If the proxy manager is not already setup on the Droplet, visit the getting started page and follow the instructions there to set it up.\nLinking a domain or subdomain to a specific IP address and Port number will require access to the DNS record settings of the domain through whatever provider it was purchased from. Also, access to the Droplet that is running the application that requires the domain is necessary, along with the ability to edit firewall settings for the given Droplet. Make sure all of this is available prior to linking the domain.\n*Note: Nginx Proxy Manager is already set up on the Cloud-infrastructure Droplet, so there is no need to set it up when linking domains to anything API related.\nLinking a Domain or Subdomain To link a a domain or a subdomain to the IP address of an application, you first want to create an A record in the DNS settings of your domain on its provider’s website. If you have linked a domain to DigitalOcean already from a different provider, this can be done from within DigitalOcean, under Domains -\u003e yourDomain -\u003e Create new record.\nTo create an A record for the domain, simply enter the hostname (such as example.com or site.example.com if linking a subdomain), enter the IP of the Droplet that the domain will direct traffic to (such as 192.168.xxx.xxx), and the Time-To-Live value (defaults to 3600 seconds). Then, hit Create Record and the A record will have been created. This is all that needs to be done for the DNS settings of the domain, so any windows regarding that can now be closed.\nOpening The Port For Nginx Proxy Manager To access Nginx Proxy Manager on the Droplet’s IP address after setup, a custom firewall setting must be configured. To do this, head over to the Droplet’s dashboard, go to the networking tab on the left under the Droplet’s IPv4 Address, scroll down to the “Firewalls” section, and click on either “Configure Firewall” or the name of an existing firewall. This will bring you to the Inbound and Outbound Rules page. From here, under Inbound Rules, click on the “New rule” dropdown button (under the existing rules). Select “Custom”, and then for the port range enter “81” and hit save. Now, when you go to “http://‘Droplet’sIPAddr’:81”, you will see the login page for the instance of Nginx Proxy Manager that is running on the Droplet. Login, and if you do not have an account already created, the login info will be “admin@example.com” with the password “changeme”. Be sure to change the username and password after logging in.\nCreating a Proxy Host To direct traffic through the domain/subdomain name to the application being hosted on the Droplet, it is necessary to create a new Proxy host in Nginx Proxy Manager for the domain/subdomain. To do so, after logging into the instance of Nginx Proxy Manager running on the Droplet, click the “Proxy Hosts” button on the left of the dashboard. From here you will be taken to the Proxy Hosts page. Go ahead and hit the “Add Proxy Host” button as seen below:\nThis will bring up the page below. Be sure to enter the domain/subdomain that you created an A record for earlier into the “Domain Names” field and hit the Tab key. Then, specify the IP address of the Droplet to direct the traffic of the link to, and finally specify the port that the application will be running on inside of the Droplet. Make sure to check each option and hit save:\nGenerating an SSL Certificate For The Domain After creating a Proxy Host for the domain, a listing similar to the following will appear in the list of Proxy Hosts:\nFrom here, click the three dots on the right of the listing and select “Edit”. Click on the “SSL” tab in the popup window, and select “Request a new SSL Certificate” and enter your email to generate the certificate by hitting the save button as seen below:\nOnce this is done, it will take a moment to generate the certificate, but soon the application will be accessible through the domain name over http and https. To force the domain to use https and avoid any http requests, go back to the SSL tab as done above and toggle the “Force SSL” slider, then hit save.\nConclusion Now, the domain should be securely accessible and linked to the Droplet’s IP address and the port that the application is running on on the Droplet. Make sure to delete the custom firewall configuration for the Droplet, and everything should be good to go!\n",
    "description": "How to link domains to an application using DNS records and Nginx Proxy Manager",
    "tags": null,
    "title": "Linking Domains",
    "uri": "/2024-capstone/how-to-contribute/linking-domains/index.html"
  },
  {
    "content": "Project Contributions Mobile Application Development Contact Information Institution Email: emains@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Liz Mains",
    "uri": "/more/members/liz-mains/index.html"
  },
  {
    "content": "Project Contributions Developed SmartDot Simulator (standalone, not unity implementation) for the purpose of reading and testing throw data. Connected simulator app to front-end MAUI app using Raspberry PI w/ python bluez library. Created and organized team discord. Contact Information Institution Email: ldodson@ycp.edu (active) External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Luke Dodson",
    "uri": "/more/members/luke-dodson/index.html"
  },
  {
    "content": "Prerequisites Before continuing with any of the following steps, make sure that you have created an account on DigitalOcean and have already created a Droplet. If you have not yet created a Droplet, see the “Creating a Droplet” page to find out how to do so.\nNavigating to the Droplet To begin learning how to manage a DigitalOcean Droplet, select the “Projects” dropdown in the top left of the main dashboard page and click on the project in which the Droplet you want to manage is located:\nYou will then be taken to the project’s dashboard, where you can see resources and activity and manage the project’s settings. Click on the resources tab and select the Droplet from the list below:\n*Note: The full name of the project, Droplet, and the full IP address of the Droplet shown are blurred for security purposes.\nDroplet Dashboard After navigating to the Droplet, you will be greated by the Droplet’s dashboard, as seen below:\nFrom here, you can view and manage a plethora of different things regarding the Droplet, including:\nTabs Details Graphs Graphical data that shows bandwidth, CPU usage, and disk I/O operations Access Access to the Droplet console, Recovery console, and reset the root password Power Turn off the Droplet or Power Cycle the Droplet Volumes Add or manage disk volumes on the Droplet Resize Upgrade the Droplet Type and CPU Options of the Droplet Networking View details of the Public and Private Networks and manage Inbound and Outbound Firewalls Backups Create backups of the Droplet (priced per month by size of Droplet) Snapshots Take a snapshot and manage previous snapshots taken of the Droplet Kernel View the status of the Kernel or enable management of it in the control panel History View all previous changes made to the current Droplet Destroy Destroy or Rebuild the current Droplet (only used to get rid of the Droplet completely) Tags Manage tags assigned to the Droplet (tags are used for grouping Droplets and are not required) Recovery Select whether to Boot from ISO or Boot from Harddrive (used if corruption in Droplet occurs) Seeing as only a handful of these tabs are necessary to use, we’ll only cover the basics throughout the rest of the steps. If more information is desired on the other tabs, finish the rest of the steps and play around inside of the Droplet’s dashboard to gain a better understanding of just what you can do to/with the Droplet from within each tab.\n*Note: All IP addresses associated with this Droplet have been crossed out for security purposes.\nAccess The access tab is the most important out of the list, as it allows the user to log into the Droplet console and Recovery console, along with giving them the ability to change the password of the “root” user. Below you will find information regarding each of the access tab’s functions.\nDroplet Console The Droplet console is what the user will use to access their Droplet, make changes, and perform any modifications/operations inside of the Droplet. Pictured below is the form for signing into the console:\nHere, the default login user is “root”, and the password for the user will be entered once the console popup window shows after clicking the “Launch Droplet Console” button. The password to enter is the same one that the user set for “root” at the time of creation of the Droplet.\nAfter logging into the console as root, the user will have full permissions to add files, edit files, run programs, setup a file transferring protocol, etc. We won’t go into the specifics since what a user does inside of their console is out of the bounds of simple Droplet management.\nRecovery Console Next is the Recovery console. In the event that one loses access to their Droplet or has lost data that they are unable to recover in the regular Droplet console, they can open a Recovery console session to attempt to recover access or potentially lost data. To access the Recovery console, simply click the “Launch Recovery Console” button on the access tab page and enter the password for the “root” user in the popup window. The button for the Recovery console looks something like below:\nAfter logging into the Recovery console, the user can select from 6 options available. These options are explained in detail when the user logs in, so there is no need to elaborate on them here.\n*Note: The Recovery console is only to be used if familiar with Ubuntu and navigating through an OS using a terminal.\nReset Root Password The “Reset Root Password” button can be used to reset the password in the event that the user has forgotten their password or has lost access to their Droplet. To do so, simply hit the button shown below and DigitalOcean will prompt accordingly.\nPower The power tab can be used to power off the Droplet completely or to Power Cycle the Droplet. Below more information can be found regarding both functions:\nPower Off The power off function can be used to shutdown the Droplet in the event that maintenence needs to be done on it or the user wants to enable IPv6 addressing for the Droplet. More details on the power off function can be seen in the following image:\nPower Cycle The power cycle function can be used to do a full restart of the Droplet, powering it off then turning it back on. More details on this can be found in the image below:\nNetworking The networking tab is where all options regarding IP addressing and firewalls are located. Below you can find more information regarding each option listed on the page:\nPublic Network The public network settings show the public IP addresses and subnets that people can access the Droplet through. In the same section, users can enable or disable public IPv6 addressing if so desired. See the below screenshot:\n*Note: All IP addresses associated with this Droplet have been crossed out for security purposes.\nPrivate Network The private network settings list the Droplet’s private IP address and the name and IP of the the Virtual Private Cloud (VPC) network. As shown below, only users that are a part of the same VPC network can connect to the Droplet using the private IP address:\n*Note: All IP addresses associated with this Droplet have been crossed out for security purposes.\nFirewalls Below you will find information regarding the firewall settings for the Droplet.\nThere are two types of firewall rules that can be configured. How one configures their firewalls depends solely on the goal of the user. Below you will find the inbound and outbound rules and what type of connections each firewall handles:\nInbound Firewall:\nThe inbound firewall handles incoming connections by a multitude of protocols such as HTTPS, SSH, and so on. To specify a port that an application on the Droplet should run on, one would simply create a “Custom” inbound firewall rule that specifies the port of the application to run. Outbound Firewall:\nThe outbound firewall handles outgoing traffic from the server different communication protocols such as ICMP, TCP, UDP, and more. These rules allow the user to specify what ports and what destinations traffic from the server is allowed to be sent to. Snapshots The snapshots tab is where users are able to create snapshot backups of their Droplet. Though it costs a bit extra to create snapshots, it is good practice to create one in the event that data gets corrupted on the Droplet or the user loses access to it and can not reset their password. Below you can see the details of creating a snapshot and that all you need to do is name the snapshot and hit “Take Live Snapshot”:\nUsers can also see previous snapshots taken in the bottom section of the page and if none were made, the output above for that section will be shown.\n*Note: The name of the Droplet snapshot has been crossed out for security purposes.\nDestroy The destroy tab can be used to permanently delete the Droplet or rebuild the droplet from a previously taken snapshot (after doing so in the above section). See the below image to get an idea of each function:\nRecovery The recovery tab is used when someone needs to restore something from the Droplet that they may have accidentally deleted or that has become corrupted. The default setting in this tab is to boot from the Droplet’s hard drive, which is what is happening each time the Droplet is turned on until the option is changed. Changing the option to boot from recovery ISO allows the user to handle different kernel mismatches and attempt to restore any corrupted data, though none of the recovery methods are guaranteed to work in the case of an emergency (deleted privilege folders, renaming of privilege folders, etc.). See below to read more about each option’s function:\n",
    "description": "How to manage a DigitalOcean droplet",
    "tags": null,
    "title": "Managing a Droplet",
    "uri": "/2024-capstone/how-to-contribute/digitalocean-management/managing-a-droplet/index.html"
  },
  {
    "content": "Project Contributions Worked with team members to build multiplatform app using .NET MAUI Established Bluetooth LE communications in MAUI app using the dotnet-bluetooth-le plugin Stylized BLE connection UI for efficent and user-friendly bluetooth interaction Worked with Simulation Team to set up BLE communication between the app and machine running the SmartDot Simulator Set up BLE functions to interact with MbientLab’s MetaMotionS module for testing purposes Assisted in setting up the revmetrix.client.api package in the MAUI app Worked with the team on papers and slideshows for progress reports Contact Information Institution Email: mhensel@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Michael Hensel",
    "uri": "/more/members/michael-hensel/index.html"
  },
  {
    "content": "Milestone 1 Main Task Your task is to demonstrate your progress toward the goals you previously established for Milestone 1. The Presentation / Demonstration Each project team should plan to present for about 50-60 minutes. Larger teams (with multiple sub-teams) will likely go longer than that. There will likely also be an extensive question and answer period. You should use presentation software such as PowerPoint or Google Slides. Your slides should contain brief bulleted points and graphics (tables, diagrams, screen captures, wire frames) that provide overall context for your bullet points. Slides should not be a “wall of text”, and please avoid reading your slides or from a prepared script. Your presentation should include the following elements: Provide a brief description of the project. Provide a high-level overview of your system architecture. Explain what tools/technologies you are using, and what role they play in your project development. Explain what parts of your design are implemented, and which parts remain to be implemented by referencing your updated UML diagram(s) and Database Schema. Demonstrate the system in action. Walk through your UI (and/or internal workflow) and explain the Use Case functionality it demonstrates. Discuss your automated test strategy, and run your unit tests to demonstrate your testing framework, and describe what is happening. Briefly talk about how you plan to evolve the system to implement the remaining functionality. Milestone 1 - Presentation / Demonstration Links The Team ",
    "description": "Progress made on milestone 1 and the associated slideshow",
    "tags": null,
    "title": "Milestone 1",
    "uri": "/2024-capstone/project-milestones/spring-2024/milestone-1/index.html"
  },
  {
    "content": "\r",
    "description": "Milestone 1",
    "tags": null,
    "title": "Milestone 1",
    "uri": "/2025-capstone/project-milestones/milestone-1/index.html"
  },
  {
    "content": "Milestone 2 Main Task The Presentation / Demonstration Milestone 2 - Presentation / Demonstration Links ",
    "description": "Progress made on milestone 2 and the associated slideshow",
    "tags": null,
    "title": "Milestone 2",
    "uri": "/2024-capstone/project-milestones/spring-2024/milestone-2/index.html"
  },
  {
    "content": "",
    "description": "Milestone 2",
    "tags": null,
    "title": "Milestone 2",
    "uri": "/2025-capstone/project-milestones/milestone-2/index.html"
  },
  {
    "content": "Milestone 3 Main Task The Presentation / Demonstration Milestone 3 - Presentation / Demonstration Links ",
    "description": "Progress made on milestone 3 and the associated slideshow",
    "tags": null,
    "title": "Milestone 3",
    "uri": "/2024-capstone/project-milestones/spring-2024/milestone-3/index.html"
  },
  {
    "content": "",
    "description": "Milestone 3",
    "tags": null,
    "title": "Milestone 3",
    "uri": "/2025-capstone/project-milestones/milestone-3/index.html"
  },
  {
    "content": "Frontend Team For the minimal system, the front end will contain a functional login page that is able to connect to a database and will contain a draft up of the output page. The output page will be able to visualize a datapoint in preparation for future milestones. There are plenty of unknowns in regards to MAUI, so research on how to create the screens and specific details will be discovered during the milestone.\nBackend Team For the minimal working system milestone, the backend team will achieve an operational database that stores login information and additional information. This simple task will serve as a proof of concept for accurate interfacing with the application and the server. Authorization headers and encryption are already present within the system, so this is not a concern for our implementation. We will also integrate the Frontend’s login page with our login endpoint. This will provide a basis for any future communications that will need to be facilitated between the Frontend and the backend.\nCommunications Team On the interface side, a working emulator of the Mbient labs MetaMotionS module will be finished for further testing purposes for the group. The emulator will allow users to send CSV data for the emulator to store whether it comes from the Unity SmartDot Simulator or previous output data from a 9DoF module. The device will then replicate the Bluetooth messages that the Mbient lab modules would send out when recording data in real-time mode. The emulator will then broadcast the data from the CSV file as if it were recording in real-time so the front-end has a reliable data source to confirm that the message passing between the computer and the Ball Spinner controller works as intended.\nWhen looking at the minimal working system for the physical SmartDot modules (which will be referred to interchangeably with the in-house Mbient Labs modules), part of the minimum working system for the project will be to retrieve the live data from one of the 3-axis sensors in the modules to print out in the terminal of the Ball Spinner Controller. This would act as proof of concept for interacting with an actual device and help with development with the SmartDot client API that will distinguish between the emulator, the SmartDot module, and the Mbient lab modules so the rest of the system will not have to.\nThe last aspect of the minimal working system for the communications team will be controlling the LED on the MetaMotionS module. This will be done by writing a script through the Ball Spinner (aka the Raspberry PI) which will interact with the SmartDot API to send data to and from the connected devices. The team feels that turning on and off the LED on the module consistently will be the easiest way to demonstrate proper communication without complicated message passing.\nMechanical Team For the minimal working system, the team will be able to spin the bowling ball in one orthogonal direction using either a human-powered design or a small controlled motor. The human-powered design focuses on showing the similar strengths it will experience; the motor design will be used to calibrate the SmartDot sensor’s factors. The SmartDot module will be mounted inside the ball’s finger hole, and we will read the ball’s rpm externally. The simple external reading methods may only correctly read in one orthogonal direction. We will create an enclosure to keep the ball secure while spinning.\nThe first foundational problem would be designing and building the enclosure to be stable. The centripetal force of the bowling ball will cause the enclosure to rattle, making it more likely to fail or fracture. These early designs will also struggle with consistency; human power tests will not be consistent, and the motor design will need a sizeable normal force from it and the ball to move properly. External measurements could also have issues with consistency caused by the ball rattling the enclosure and finding its preferred spin axis. All of these issues increase the level of difficulty in calibrating the system to our needs.\nSimulation Team The minimum working system for the simulation will be a text-based output on information (i.e. variables) involving how the ball is expected to go down the lane. This output data will either be displayed in a text box or console window. While the simulation will incorporate visual output later, a text-based simulation is an efficient way to relay a proof of concept for the calculations behind the visualization. The simulation will work based on the inputs given by the user and will output data in real-time similar to how the Ball Spinner would send real-time data of the projected throw to the Application. One potential issue with the simulation will be determining the accuracy since the Visual Simulation will be used as a baseline comparison for the Ball Spinner movement. This will be continuously worked on in future milestones by communicating with the other teams and client.\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Minimum Working System",
    "uri": "/2024-capstone/project-assignments/fall-2024/requirements/minimum-working-system/index.html"
  },
  {
    "content": " The setup process is the same as the ball spinner application for .net maui\nWe use two additional NuGet packages\nOur github repo link: https://github.com/YCP-Rev-Metrix/Cellular.git ",
    "description": "Instrucations",
    "tags": null,
    "title": "Mobile App",
    "uri": "/2025-capstone/set-up/mobile-app/index.html"
  },
  {
    "content": "Overview Below you’ll find instructions on how to setup your development environment for the mobile application. All tools and technologies needed can be found with their version numbers on the Technologies Used page, along with the same download links provided there being seen throughout this guide. There are a handful of tools needed and steps to be followed, so buckle up:\nInstalling The JetBrains Rider IDE The first thing needed to setup your dev environment is your IDE. For this, we’ll use JetBrains Rider, which can be found downloaded here. The setup for Rider can be followed using all of the defaults, so the installation is very straightforward. However, we’ll be coming back to Rider to setup our JDK locations for android development and such.\nInstalling .NET MAUI and Xamarin The next tool we’ll need is .NET MAUI with Xamarin, which can be installed pretty easily using the Visual Studo Installer. We’ll cover how to install MAUI two ways: by modifying an existing installation of Visual Studio 2022, or by installing Visual Studio from scratch:\nInstalling Visual Studio 2022 If this is your first time installing Visual Studio on your machine, go ahead and run the installer found here. Once the section where you select which workloads you would like to install pops up, go ahead and select the following (including the optional checkboxes under “.NET Multi-platform App UI Development”):\nFrom here, you may continue the installation as normal and that is all that needs to be done relating to Visual Studio.\nModifying An Existing Installation of VS 2022 If you already have Visual Studio 2022 Community edition installed on your machine, you can simply run the Visual Studio Installer and click the “modify” button on VS 2022:\nNow, scroll to the “.NET Multi-platform App UI Development” option and select it:\nAfter selecting MAUI as seen above, navigate to the tab on the right listing the installation details. Under the .NET Multi-platform App UI Development dropdown, open the optional dropdown and select “Xamarin”:\nNow, continue the installation as normal, this is all that needs to be done regarding Visual Studio.\nCloning the MauiApp2 Project To clone the mobile application from GitHub into Rider, head over to the repository found here. Select the green “code” button, and copy the Https link that pops up:\nOpen the Rider IDE and you’ll be met with the welcome screen. From here, click on “Get from VCS” button in the top right of the screen: Now go ahead and paste the link that you copied into the URL field and select the path in which you would like to save the project as seen here:\nSelect the Clone button in the bottom right of the screen, and Rider will do the rest. Now, the project has been cloned, but rest assured there will be errors because we still need to configure a few things inside of Rider, such as the OpenJDK 17 path.\nInstalling Microsoft OpenJDK 17 OpenJDK 17 is required for Android development for this project. Go ahead and download Microsoft’s OpenJDK 17, found here. After running the installer, select the default installation paths listed during the setup, and continue as normal. From here, we’ll open up the JetBrains Rider IDE that we installed earlier and set the Java SDK path under the Android settings to the path that we previously installed the OpenJDK 17 to. To do this, click the “Main Menu” button (4 horizontal lines) in the top left of the top navigation bar, select the “File” dropdown, then select “Settings”:\nInside of the settings, select the “Build, Execution, Deployment” dropdown and click on “Android”:\nNow, click the dropdown for the “Java Development Kit Location” and select the “…./jdk-17.0.9.8-hotspot” option:\nIf the option is not listed, click the three dots to the right of the same dropdown and browse through the filesystem to select the path to the JDK specified during installation.\nInstalling NuGet Pacakages for the API Client As can be seen in the list of errors in Rider, there are plenty of errors regarding the classes Client, Common, and FeaturedAPI. This is due to having not installed the NuGet packages for the API Client. In order to do this, you’ll need to add the RevMetrix GitHub as a NuGet source for the project in Rider. However, we’ll need to validate ourselves to this new source first. Head over to GitHub and add a classic token, set the expiration to one Year and be sure to select Read and Write permissions to Packages. (See example below).\nCreate the token, copy the value, and store the token in a safe place (you will not be able to re-access the token on GitHub). Go ahead and copy the token and open the Rider IDE.\nHead to the top navigation bar, select the “Main Menu” button, select the “Tools” dropwdown, select “NuGet”, and select the “Manage NuGet Packages for MauiApp2”:\nFrom the new popup window for NuGet, select the sources tab and click on the path that includes your username:\nNow, in the right tab of the same sources menu, click the green plus button next to the “New feed” item listed in the “Feeds” tab:\nA popup window named “Editing: New feed” will appear, and the fields should be filled out as the following:\nThe field values should be filled out as such:\nName: RevMetrix URL: https://nuget.pkg.github.com/YCP-Rev-Metrix/index.json User: Your GitHub Username Password: Your Classic Token (the token previously generated) Go ahead and save this, then head over to the Packages tab of the NuGet window. Enter “RevMetrix” into the search bar, and from the options available select “revmetrix.client.api”:\nNow, in the right side of the window, click the green plus button and click “Install” to successfully install the NuGet package:\nAfter installation is complete, we are finished with NuGet packages because the Client package automatically installs the Common package too.\nInstalling and Configuring Android 13.0 (API Level 33) A crucial part of the mobile app development is having the correct Android SDK installed and selected. To do this, click the “Main Menu” button (4 horizontal lines) in the top left of the top navigation bar, select the “Tools” dropdown, and navigate to the “Android” option, and select the “Android SDK Manager” option:\nAfter selecting the Android SDK Manager, go ahead and install the following list item:\nContinue with the installation as normal. Once finished, no more action should be required for the Android portion of the application outside of the installation of the Android emulator (seen below).\nInstalling the Android Emulator Troubleshooting If you get the error: Error NETSDK1147: To build this project, the following workoads must be installed: xyz\nRun: dotnet workload restore (This will most likely occur the first time you pull the repo and it installs any workloads needed)\nRun: dotnet restore (This restores the dependencies and tools of the project)\nIf you get the error: NU1101: unable to find package RevMetrix.Client.Api No packages exist with this id in source(s) OR NU1301: Unable to load the service index for source RevMetrix.Client.Api\nThis means you need to (re)create a token in GitHub and follow the steps of setting up the Nuget package\nOnce that step is done invalidate caches and restart (File -\u003e Invalidate Cache -\u003e Invalidate Caches and Restart)\n",
    "description": "How to setup your development environment for the mobile app",
    "tags": null,
    "title": "Mobile Application",
    "uri": "/2024-capstone/how-to-contribute/getting-started/mobile-app/index.html"
  },
  {
    "content": "Mobile Application Overview The purpose of the mobile application is to provide users with an intuitive way to record and view their bowling performance data. The application allows users to store and manage a variety of data, including Events, Sessions, Games, Frames, Shots, Bowling Establishments, Bowling Balls, and Account information.\nShot Page The shot page is the base of the mobile application. It contains a frame view at the top to show the pins knocked down on each shot, as well as the game’s score. Below that, there are buttons and input fields used to track a full game of bowling.\nThe input fields on the left of the screen allow users to select a player, as well as a strike ball and spare ball used for each frame. The buttons on the right are shortcuts for users to select if they get a Foul, Gutter, Spare, or Strike. The slider below the pin buttons lets the user select which board the ball hit at the end of the lane. The Next button is used to submit each shot and progress through a game.\nThe session page allows users to create new sessions and view old ones.\nDatabase All data is stored locally on the device using SQLite, ensuring quick access and offline functionality The application includes functionality to save and load individual frames and shots, enabling detailed tracking of each game. The application is linked to the existing cloud database through a test SQL table, laying the groundwork for future features such as data backup and cross-device synchronization.\n",
    "description": "Cellular",
    "tags": null,
    "title": "Mobile Application",
    "uri": "/2025-capstone/cureent-state-of-revmetrix/cellular/index.html"
  },
  {
    "content": "Milestone 1 Main Task The task is to demonstrate a minimal working version of your system. For a “minimal” working system: Your minimal working system should implement the most important classes in the core object model, and test them comprehensively using unit tests What are the most important requirements of your system? You should be able to demonstrate to us that they are at least partially implemented, with appropriate navigation between the components of the system. Extremely important: whatever functionality you demonstrate should be implemented in your core object model classes. We do not want to see a hacked-together “prototype” that looks good but internally is spaghetti code. Also, do NOT demonstrate your system components in isolation - those components should be interacting with each other, at least on a basic level. Because this milestone involves implementing several of your most important use cases or user stories, you will need to make sure that your use cases/user stories are documented. Make sure that your project’s issue tracker has an issue for each use case, and each use case issue has a reasonably detailed textual description of the use case. You can write your use cases as full-blown use cases (see Chapter 9 of UML Distilled). The important concern is that you document the important functionality of the system from the perspective of the user. You will not receive full credit for implementing use cases unless they are documented. The Presentation / Demonstration Each project team should plan to present for about 45 to 60 minutes. Larger teams (with multiple sub-teams) will likely go longer than that. There will likely also be an extensive question and answer period. All presentations need to be limited to less than two hours (including the question and answer period).\nYou should use some presentation software such as PowerPoint or Google Slides. Your slides should contain brief bulleted points and graphics (tables, diagrams, screen captures, wire frames) that provide overall context for your bullet points. Slides should not be a “wall of text”, and please avoid reading your slides or from a prepared script.\nYour presentation should include the following elements:\nProvide a brief description of the project. Provide a high-level overview of your system architecture. Explain what tools/technologies you are using, and what role they play in your project development. Explain what parts of your design are implemented, and which parts remain to be implemented by referencing your updated UML diagram(s) and Database Schema. Demonstrate the system in action. Walk through your UI (and/or internal workflow) and explain the Use Case functionality it demonstrates. Discuss your automated test strategy, and run your unit tests to demonstrate your testing framework, and describe what is happening. Briefly talk about how you plan to evolve the system to implement the remaining functionality. Please do a dry run before class. Because of the limited amount of time we have in class, we can’t wait for your team to troubleshoot issues that arise during the presentation. Milestone 1 - Presentation / Demonstration Links The Google Slides presentation for milestone 1 can be found here.\nThe Team ",
    "description": "Progress made on the minimal working system and the associated slideshow",
    "tags": null,
    "title": "MS1 - Minimal Working System",
    "uri": "/2024-capstone/project-milestones/fall-2023/ms1---minimal-working-system/index.html"
  },
  {
    "content": "Milestone 1 ",
    "description": "Progress made on the final working system and the associated slideshow",
    "tags": null,
    "title": "MS1 - Minimal Working System",
    "uri": "/2024-capstone/project-milestones/fall-2024/ms1---minimal-working-system/index.html"
  },
  {
    "content": "Main Task The task is to demonstrate a 50% working version of your system. For a 50% working system: You should have implemented the majority of the pages and navigation between those pages for your UI. You should present the major Use Cases by giving a demo of the navigation. This does not mean that every page is fully functional, but rather that the majority of the pages exist, and that button and other navigation functionality works. You should be able to use multiple pages to enter, modify, delete information. And, those changes should be persistent, meaning that they are reflected in your database. You should be able to show that the various components of your system interact with each other. For example, if you have a system that involves a website, a mobile app (or access via a mobile device), hardware and/or HW simulator, and a backend server/DB, show that you have a functional end-to-end connection between all of those components. You should have a significant number of test cases that cover your controller scenarios (not just getter and setter tests). If you have established a CI/CD (continuous integration/continuous development) server, show that it works. The Presentation / Demonstration Each project team should plan to present for about 45 to 60 minutes. Larger teams (with multiple sub-teams) will likely go longer than that. There will likely also be an extensive question and answer period. All presentations need to be limited to less than two hours (including the question and answer period). You should use some presentation software such as PowerPoint or Google Slides. Your slides should contain brief bulleted points and graphics (tables, diagrams, screen captures, wire frames) that provide overall context for your bullet points. Slides should not be a “wall of text”, and please avoid reading your slides or from a prepared script. Your presentation should include the following elements: Provide a brief description of the project. Provide an updated high-level overview of your system architecture. Explain what tools/technologies you are using, what role they play in your project development, and any changes you may have made since Milestone 1. Explain what parts of your design are implemented, and which parts remain to be implemented by referencing your updated UML diagram(s) and Database Schema. Walk through your UI (and/or internal workflow) and explain the use case functionality it demonstrates. Discuss your automated test strategy, and run your unit tests to demonstrate your testing framework, and describe what is happening. Briefly talk about how you plan to evolve the system to implement the remaining functionality. Plan your demonstration carefully. You need to convince us that your system is 50% complete. Make sure your demonstration convinces us! Please do a dry run before class. Because of the limited amount of time we have in class, we can’t wait for your team to troubleshoot issues that arise during the presentation. Milestone 2 - Presentation / Demonstration Links The Google Slides presentation for milestone 2 can be found here.\n",
    "description": "Progress made on the 50% working system and the associated slideshow",
    "tags": null,
    "title": "MS2 - 50% Working System",
    "uri": "/2024-capstone/project-milestones/fall-2023/ms2---50-working-system/index.html"
  },
  {
    "content": "Milestone 1 ",
    "description": "Progress made on the final working system and the associated slideshow",
    "tags": null,
    "title": "MS2 - 50% Working System",
    "uri": "/2024-capstone/project-milestones/fall-2024/ms2---50-working-system/index.html"
  },
  {
    "content": " ",
    "description": "Progress made on the final working system and the associated slideshow",
    "tags": null,
    "title": "MS3 - Final System",
    "uri": "/2024-capstone/project-milestones/fall-2024/ms3---final-working-system/index.html"
  },
  {
    "content": "Main Task The task is to complete a final report documenting your project, and to give a presentation on the project. Our expectations for the report are described in the Final Report Details document. We strongly encourage you to make an appointment and visit the Writing Center in the Center for Teaching and Learning to get help from a writing tutor. Bring your document with you! Presentation Guidelines Each project team will give a presentation of about 60 to 75 minutes. Larger teams (with multiple sub-teams) will likely run longer. There may also be an extensive question and answer period. All presentations need to be limited to less than two hours (including the question and answer period). You should use some presentation software such as PowerPoint or Google Slides for your presentation. Your slides should contain brief bulleted points and graphics that provide overall context for your bullet points. Slides should not be a “wall of text”, and please avoid reading your slides or a prepared script. NOTE: You will have already submitted your draft technical report before your final milestone presentation. You can leverage the draft report contents for the figures, diagrams, pictures, screen captures, etc that will appear in your presentation. Please rehearse your presentation! We can’t allow any presentation to go over its allotted time. You may wish to have a few notecards for reference. However, you should not read directly from your notecards or from your slides. This makes for a very boring and painful presentation. Keep in mind that the audience for your presentation consists of students and faculty in CS and Engineering, as well as your clients, alumni and technical advisors. Don’t assume that the audience knows anything about your specific project. However, you may assume that the audience is reasonably knowledgeable about computers, software, etc. Don’t get too bogged down in details. As with any form of technical communication, you want to emphasize the most important and interesting information. Provide supporting details if they are necessary, but otherwise try to keep the presentation at a fairly high level. Here is a suggested structure for your presentation: Background: What problem were you trying to solve? Discuss the state of the project at the begining of the Fall, and the new/modified system requirements that you addressed. Show a diagram of your overall system architecture, how the pieces fit together and interact, and how data flows between them. Analysis and design: Discuss your design model. In this part of the presentation, you must show a UML class diagram illustrating the most important classes and methods in your system, and how they relate/interact with each other. Please use multiple UML diagrams if a single diagram would have too many classes. You must also show your Database Schema, and show how your tables interact with your classes. You may also use multiple slides for your datbase schema for clarity. This is also a good opportunity to discuss how the design of the system changed as you worked on the implementation. Discuss the development tools/technologies that you ended up using. Describe what they contribute to the project. Implementation: What were the most interesting things you encountered/learned when you implemented the system? If you used any interesting programming techniques, this is a good opportunity to discuss them. Do not show code during your presentation. Demonstration: Show your system working. Demonstrate the most important/interesting features. You should have a scripted demonstration that you practiced multiple times prior to the presentation. One person runs the demonstration while others describe what is happening, and why. You do NOT need to show every feature of your software, but certainly show the most important/interesting/challenging aspects of your project. If you have a multiple major components to your system (frontend UI, mobile app, HW, simulator, backend server/DB), demonstrate end-to-end scenarios where information from one end reaches all the eay to other end, and possibly back again. Discuss your automated test framework, and demonstrate it in action. Future Work: Since most teams are working on multi-semester/multi-year projects, describe the state of the project as it will be for the incoming team in the Spring. Also, show that the future work you present is captured as issues in your issue tracker. Many of you may be resuming work on the same project in the Spring, and there could be new students joining the project. Conclusions: Sum up what you accomplished and what you learned, particularly for underclassmen. If there are aspects of the project you would do differently if you started again from scratch, mention them. You can also talk about how you might want to extend the system in the future. All of the members of your team must make significant contributions to the presentation. Milestone 3 - Presentation / Demonstration Links The Google Slides presentation for milestone 3 can be found here.\n",
    "description": "Progress made on the final working system and the associated slideshow",
    "tags": null,
    "title": "MS3 - Final Working System",
    "uri": "/2024-capstone/project-milestones/fall-2023/ms3---final-working-system/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Patrick Devine",
    "uri": "/more/members/patrick-devine/index.html"
  },
  {
    "content": ".NET MAUI documentation: -Bluetooth Connection\n-NET MAUI General Documentation\n-NET MAUI File Picker\n-NET MAUI Youtube Channel\n-Xamarin Youtube Channel\n-Xamarin Data Binding Documentation\n-Xamarin Advanced Data Binding Documentation\nInitial Proof of Concept - Mobile Application ",
    "description": "Drawing board ideas for the layout and interaction methods of the phone application",
    "tags": null,
    "title": "Phone App - Proof of Concept",
    "uri": "/2024-capstone/initial-project-ideas/phone-app---proof-of-concept/index.html"
  },
  {
    "content": "Overview Below you can find the list of semesters that RevMetrix was under development and their respective assignments and details.\nDevelopment Semesters Fall 2023A list of all assignments completed throughout the fall 2023 semester\nFall 2024Design and Analysis Information and Links to the Document and Slideshow\nSpring 2024A list of all assignments completed throughout the spring 2024 semester\n",
    "description": "A list of all assignments completed throughout the fall 2023 semester",
    "tags": null,
    "title": "Project Assignments",
    "uri": "/2024-capstone/project-assignments/index.html"
  },
  {
    "content": "Overview Below you can find the assignment descriptions for each of the project’s semester milestones. There are three in total per semester, and once the assignment date has passed, the appropriate slideshow can be seen under each milestone’s title.\nMilestones Fall 2023The progress made prior to each project milestone during the fall 2023 semester\nFall 2024The progress made prior to each project milestone during the fall 2023 semester\nSpring 2024The progress made prior to each project milestone during the spring 2024 semester\n",
    "description": "The progress made prior to each project milestone",
    "tags": null,
    "title": "Project Milestones",
    "uri": "/2024-capstone/project-milestones/index.html"
  },
  {
    "content": "\rMilestone 1Milestone 1\nMilestone 2Milestone 2\nMilestone 3Milestone 3\n",
    "description": "2025 spring Project Milestones ",
    "tags": null,
    "title": "Project Milestones",
    "uri": "/2025-capstone/project-milestones/index.html"
  },
  {
    "content": "\r",
    "description": "2025 ",
    "tags": null,
    "title": "Project Proposal",
    "uri": "/2025-capstone/project-assignments/project-proposal/index.html"
  },
  {
    "content": "Official Project Requirements Document and Slideshow The official project requirements document can be found in the project’s Google Drive here, and the requirements presentation slideshow can be found here\nSystem Architecture Initial Requirements by Type of Develeopment Backend RequirementsProject requirements specific to the backend development\nFrontend RequirementsProject requirements specific to the frontend development\nSimulation RequirementsProject requirements specific to the simulation development\n",
    "description": "Details of the project requirements and the associated slideshow",
    "tags": null,
    "title": "Project Requirements",
    "uri": "/2024-capstone/project-assignments/fall-2023/project-requirements/index.html"
  },
  {
    "content": "Overview Below you can find the list of project assignments completed throughout the fall 2024 semester and all of their details.\nList of Assignments ArchitectureDesign and Analysis Information and Links to the Document and Slideshow\nCurrent SystemDesign and Analysis Information and Links to the Document and Slideshow\nDesign ApproachDesign and Analysis Information and Links to the Document and Slideshow\nFuture ImplementationsDesign and Analysis Information and Links to the Document and Slideshow\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Proposal",
    "uri": "/2024-capstone/project-assignments/fall-2024/proposal/index.html"
  },
  {
    "content": "Overview Below you can find the list of project assignments completed throughout the fall 2024 semester and all of their details.\nList of Assignments 50% Working System Design and Analysis Information and Links to the Document and Slideshow\nAbstractDesign and Analysis Information and Links to the Document and Slideshow\nFinal Working System Design and Analysis Information and Links to the Document and Slideshow\nGeneral Project RequirementsDesign and Analysis Information and Links to the Document and Slideshow\nGeneral Project RequirementsDesign and Analysis Information and Links to the Document and Slideshow\nMinimum Working SystemDesign and Analysis Information and Links to the Document and Slideshow\n",
    "description": "Design and Analysis Information and Links to the Document and Slideshow",
    "tags": null,
    "title": "Requirements",
    "uri": "/2024-capstone/project-assignments/fall-2024/requirements/index.html"
  },
  {
    "content": "Overview Table of Contents Overview Table of Contents API Subsections Preface Configuration appsettings.json Program.cs Environment variables Database Interactions API Subsections Adding \u0026 Managing EndpointsHow to Add or Manage an Endpoint\nSecuritySecurity information regarding the WebAPI\nWeb API ClientInformation regarding the Client side of the Web API\nPreface The WebAPI can be complicated from the outside, but after a bit of work, it’s actually not too confusing. There are serveral portions that will be interesting to us, all of which located in Server project.\nConfiguration appsettings.json This file contains general settings for running in different environemnts and with different configurations. Take a look below at the example. Adding to this is farily simple. Config.cs opens the file at runtime and sets relevant variables such as AuthAudience.\n{ \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft.AspNetCore\": \"Warning\" } }, \"ApiSettings\": { \"Auth\": { \"Audience\": \"RevMetrix\", \"Issuer\": \"https://localhost:7238/\", \"SecretLength\": 32 } } }Program.cs Through this, the authentication (JWT), Middleware, Swagger, and endpoints are all configured. This will run every time and cannot be modified as much based on the enironment or run settings. There is a small area for if the environemnt is development. Below is a snippet taken from Program.cs.\n_ = builder.Services.AddSwaggerGen(); _ = builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u003e { options.TokenValidationParameters = new TokenValidationParameters { ValidateIssuer = true, ValidateAudience = true, ValidateIssuerSigningKey = true, ValidateLifetime = true, ValidIssuer = Config.AuthIssuer, ValidAudience = Config.AuthAudience, IssuerSigningKey = ServerState.SecurityHandler.AuthorizationSigningTokenKey, ClockSkew = TimeSpan.FromMinutes(5) }; }); WebApplication app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { _ = app.UseSwagger(); _ = app.UseSwaggerUI(); } // app.UseHttpsRedirection(); // Verify token not blacklisted _ = app.UseMiddleware\u003cVerifyJWTBlacklistMiddleware\u003e();Environment variables Environment variables in our case are set by external programs. Take a look at below at AbstractDatabase from the DatabaseCore project. Here, the environment variable ‘DOCKERIZED’ is checked, if it has been set, then the DB connection string will change. Inside of the docker config, this environment variable is set, allowing the DatabaseCore to know that it is inside of docker, so it may connect to the DB correctly.\npublic AbstractDatabase(string databaseName) { // Get DOCKERIZED environment variable string? DockerizedEnviron = Environment.GetEnvironmentVariable(\"DOCKERIZED\"); if (DockerizedEnviron == \"Dockerized\") { // Running in docker ConnectionString = $\"Server=sql_server;database={databaseName};User Id=SA;Password=BigPass@Word!;TrustServerCertificate=True;\"; } else { // Likely running locally ConnectionString = $\"Data Source=localhost;database={databaseName};Integrated Security=True;TrustServerCertificate=True;\"; } LogWriter.LogInfo($\"DB Connection: {ConnectionString}\"); DatabaseName = databaseName; Initialize(); } Database Interactions ",
    "description": "Information on how to use the WebAPI",
    "tags": null,
    "title": "RevMetrix WebAPI",
    "uri": "/2024-capstone/how-to-contribute/webapi/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Robert Fields",
    "uri": "/more/members/robert-fields/index.html"
  },
  {
    "content": "Project Contributions Created and currently maintaining \u0026 updating the Wiki documentation site for all teams (docs.revmetrix.io) Created and currently maintaining the DigitalOcean Droplet server hosting all backend projects Domain servicing for revmetrix.io and revmetrix.xyz (linking domains \u0026 subdomains, editing DNS records, etc.) Setup remote SQL Server database connections for the backend team Assisted with debugging of revmetrix.common.api and revmetrix.client.api NuGet packages Created and styled diagrams using Draw.io Containerized backend applications using Docker Configured domain destinations with SSL certificates using NGINX Proxy Manager Worked on papers and slideshows for the project extensively with the rest of the team Assisted in development environment setup for backend team members Contact Information Institution Email: rwood7@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Robert Wood",
    "uri": "/more/members/robert-wood/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Ryan Curry",
    "uri": "/more/members/ryan-curry/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Sam Diskin",
    "uri": "/more/members/sam-diskin/index.html"
  },
  {
    "content": "Table of Contents Https Authentication and Authorization JWT Refresh Tokens Roles Middleware Secure Randomization Security Methods Hashing Salting Signing Encryption Security is a crucial part of the Web API and security is managed in multiple ways. Please ensure that the security of the application remains during development.\nHttps Our server forces the use of HTTPS for security purposes, to ensure data sent between the API and Client is encrypted. Specifically, we use TLS, the modern version of SSL.\nLearn more here\nAuthentication and Authorization Authentication and Authorization are the two primary ways of limiting a resource to specific users.\nAuthentication is the process of validating a user’s identity through credentials such as username and password.\nAuthorization is the process of limiting specific resources through roles or permissions. ie. only admins may change a user’s name.\nJWT JWT is an acronym standing for Json Web Token and it is used to provide both Authentication and Authorization to users. This token is granted to the user upon login, set-up by the following in Program.cs:\n_ = builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u003e { options.TokenValidationParameters = new TokenValidationParameters { ValidateIssuer = true, ValidateAudience = true, ValidateIssuerSigningKey = true, ValidateLifetime = true, ValidIssuer = Config.AuthIssuer, ValidAudience = Config.AuthAudience, IssuerSigningKey = ServerState.SecurityHandler.AuthorizationSigningTokenKey, ClockSkew = TimeSpan.FromMinutes(5) }; });The above specifies that JWTs on our server use the following:\nIssuer validation Audience validation Expiration validation (JWTs expire after a specified time) Issuer (us) Audience (us) Signing key (from server state) Clock skew (in case the clocks are a few minutes off) The big thing here is the expiration and signing. When a JWT is created by the server, it is assigned an expiration time, normally just a few hours in the future, at which point the JWT will no longer be validated. This new JWT is then signed by the server so that the server can detetect if a someone has tampered with the token as all data is in plaintext.\nThe server will also add to the JWT, the user’s roles, username, and a random id.\nView a real server JWT here\n\"header\" { \"alg\": \"HS256\", \"typ\": \"JWT\" } \"payload\" { \"sub\": \"Test User\", \"jti\": \"352bbdc1-0645-4a0f-b2cb-44c5d93fad7f\", \"iss\": \"https://localhost:7238/\", \"aud\": \"RevMetrix\", \"role\": \"user\", \"nbf\": 1698882420, \"exp\": 1698886020, \"iat\": 1698882420 }Learn more here\nRefresh Tokens Refresh tokens are used by the client to request a new JWT from the server when their current one expires. The server, when authorizing the user, will provide back a JWT and Refresh token. In the future, this Refresh token can be use to re-authorize the user. These tokens are just random bytes though could have taken the form of a JWT too: II7IWJueHQjdaxN28MfG7yGuR5KonICYVuexvFIYjiY=\nCurrently, these are stored in the DB with an expiration data and assosiated user.\nLearn more here\nRoles Roles are used to manage user’s abilities and controls and should be handled as security items. Endpoints or controllers that require specific roles will have the following attribute [Authorize(Roles = \"Admin, Manager\")]. This specific example allows only users with either the role of ‘User’ or ‘Manager’ to access this item. Items without the Roles specification will allow a user with any role to access it.\nThese roles are stored in the User DB in the user table as an array\nMiddleware Middleware is a method by which the server may interrupt a client’s communication to an API endpoint and manipulate data or block the request. This has been used to ensure that a user’s JWT has not been blacklisted prior to access of a protected endpoint. Relevant code is shown below:\npublic class VerifyJWTBlacklistMiddleware : IMiddleware { public async Task InvokeAsync(HttpContext context, RequestDelegate next) { Endpoint? endpoint = context.GetEndpoint(); if (endpoint != null) { if (endpoint.Metadata.GetMetadata\u003cAuthorizeAttribute\u003e() != null) { string? token = context.Request.Headers[\"Authorization\"].FirstOrDefault()?.Split(\" \").Last(); if (!string.IsNullOrEmpty(token)) { if (!ServerState.TokenStore.IsAuthorizationBlacklisted(token)) { await next.Invoke(context); return; } } context.Response.StatusCode = 401; return; } } await next.Invoke(context); } }The middleware must also be registered with the application in Program.cs\n// Verify token not blacklisted _ = app.UseMiddleware\u003cVerifyJWTBlacklistMiddleware\u003e();Secure Randomization Not all random functions are created equal. Take Python for example, if you wanted to generate secure randomness, you should not use the Random library as it is not built for cryptology and is susceptible to timing attacks and seed cracking. This applies to C# too, so we use the System.Security.Cryptography module, which provides the RandomNumberGenerator class which is secure.\nA SecurityHandler class has been created to abstract security items in a way that makes sense to more developers, allowing them to avoid worrying about security as much. This class has secure methods to generate random byte arrays, tokens, and other simple methods.\nAn instance of this class may be used from the static ServerState.\nSecurity Methods Passwords remain one of the primary methods to ensure a specific user’s security and users may not always change their password for all the services they use. This means that it is the job of our applicaiton, to ensure that these passwords are stored and used safely. There are many things that go into modern security measures. Here, we will cover the four main topics used in our application.\nHashing Hashing is the method by which a password is turned from plaintext to a format that cannot be reversed. This ensures that if the DB is leaked to the public or if someone has access to it, the passwords themselves remain secure. The WebAPI currently uses SHA256 (for simplicity - this should be changed to something meant for passwords) to generate password hashes however this may easily be change. Hashing will always generate the same output given the same input\nWe can convert our password from a string into hex so it may be hashed: abc123 -\u003e 0x616263313233\nWe can then run SHA256 on this: SHA256(0x616263313233) -\u003e 0x6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090\nThese hashed values can then be stored in the DB. When a user needs to be authenticated through the WebAPI, they provide their password, it is hashed, then compared with the hashed real password in the DB\nWe can convert an incorrect password from a string into hex so it may be hashed: incorrectPassword -\u003e 0x696E636F727265637450617373776F7264\nUsing the incorrect password: SHA256(696E636F727265637450617373776F7264) -\u003e 0x11e56efd5eae13673eccfed917ac1d69f02a8d0b8a4c384c5cc18c1bd2b7dc29 != 0x6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090\nUsing the correct password: SHA256(0x616263313233) -\u003e 0x6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090\nOnline ASCII to hex converter\nOnline SHA256 generator\nExternal hash explanation\nSalting Salting is the method of adding randomness to hashed passwords, so that the same password, when hashed on multiple sites or by different users will not generate the same hash. This means that if a user re-uses passwords, a DB leak will not give this information away as the password hash will appear different. This also means that if two users have the same password, a DB leak will not give this information away as the password hash will appear different.\nA salt is just a random hex value such as: 0x9a66190e4f\nWe can turn the password from a string into hex: abc123 -\u003e 0x616263313233\nLet’s append the salt to the end of the password hex: 0x616263313233 + 0x9a66190e4f -\u003e 0x616263313233|9a66190e4f\nLet’s hash this now: SHA256(0x616263313233|9a66190e4f) -\u003e 0x6509f3df9e7fa53ef15ae4dbc76717097982c59f0e7571bfcd5c864377432cab\nWhen we store this salted and hashed password, we can store the salt that we used too in plaintext in the DB, then in the future, when we need to authorize with a provided password, we can salt that with the same salt that was used for the real password in the DB.\nExternal salt explanation\nRandom salt / hex generator\nSigning Signing is the process of generating a unique value that represents a plaintext value combined with the server’s random cryptographic key.\nLearn more here\nEncryption Encryption is the process of securing text in a way that only the specified parties can read it.\nLearn more here\n",
    "description": "Security information regarding the WebAPI",
    "tags": null,
    "title": "Security",
    "uri": "/2024-capstone/how-to-contribute/webapi/security/index.html"
  },
  {
    "content": "\r.Net UpgradeInstrucations\nBall Spinner ApplicationInstrucations\nMobile AppInstrucations\n",
    "description": "for help ",
    "tags": null,
    "title": "Set up ",
    "uri": "/2025-capstone/set-up/index.html"
  },
  {
    "content": "Beginning Ideas of Simulation Design: Initial Lane Setup Full Lane View Lane While Testing Translation Scaled Pins Setup ",
    "description": "The base ideas around using Unity for the development of a bowling simulation",
    "tags": null,
    "title": "Simulation - First Thoughts",
    "uri": "/2024-capstone/initial-project-ideas/simulation---first-thoughts/index.html"
  },
  {
    "content": " Luke Dodson, Bryce Neptune, Enoch Sam, Ian Viveiros SmartDot Dataflow Diagram Minimal Working System The minimal working system will consist of a basic physics simulator and a SmartDot simulator that can run on pre-recorded data. The SmartDot simulator will imitate the actual hardware but will receive data from data files instead of sensing the environment. It will send this data to the mobile device via Bluetooth. The physics simulator will maintain realistic physics (friction, momentum, rotational acceleration, etc.), but in a simple environment. The lane will act as a flat object with a uniform coefficient of friction.\nIssues The biggest challenge for making the minimal working system will be properly imitating the SmartDot module. The SmartDot simulator will have to have sensors, memory, process synchronization, and data transfer protocols. Simulating all of that in C# will be quite difficult. Additionally, another issue will be verifying that the simulated physics works as it does in real life.\n50% Working System Once the minimal working system is complete. The next step will be to extend the functionality of the SmartDot simulator. The fifty percent milestone will feature the ability to generate new data. The physics simulator will allow users to enter initial parameters to determine how the ball is thrown. The SmartDot simulator will then have sensors that can actually collect the data from the throw and store it. This will allow the simulator to generate new data.\nIssues The most serious challenge for this step will be developing accurate sensors in Unity. The sensors will have to detect light and acceleration and output it in proper binary format. Getting the information might be difficult as there may not be support for it in the Unity framework. There will have to be research into that later.\nFinal Working System The final working system for this semester will have two additional features. The first will be the visualizer. The visualizer will record videos of each throw and save it to the local machine. These videos will then be used by the front end when testing their image processing software. The second feature will be a more realistic environment for the simulator. That will include lighting patterns and lane textures. The lighting patterns will imitate the lighting patterns at bowling alleys. This will help generate more accurate data from the light sensors. In addition, the lane will also have small variations in the surface and oil patterns that will affect how the ball rolls down the lane. This will help increase the accuracy of the accelerometer data.\nIssues Setting the groundwork for the Visualizer will be the physics simulation, the videos produced by this simulation have to be compatible with everything developed for image processing. So having the digital visualization match the same parameters as real-life footage is predicted to be a delicate and tedious task. It is expected that the camera angle may be adjusted multiple times during the same playback, so that multiple angles may be captured of the same shot. This will allow Image Processing to be developed in a more robust, and consistent manner.\n",
    "description": "Project requirements specific to the simulation development",
    "tags": null,
    "title": "Simulation Requirements",
    "uri": "/2024-capstone/project-assignments/fall-2023/project-requirements/simulation/index.html"
  },
  {
    "content": " Luke Dodson, Bryce Neptune, Enoch Sam, Ian Viveiros SmartDot Simulation The SmartDot Module will be a small device that can be placed in the finger insert of a bowling ball. It will record rotational and positional data about each ball throw and transmit this data via bluetooth to the mobile device. The SmartDot will have two sensors: an 3-axis accelerometer and an ambient light sensor. The light sensor will be used to detect start up conditions by sensing light-to-dark and dark-to-light transitions. It will also help record rotational information by sensing when the ball is pointing up (light) and when the ball is pointing down (dark). The accelerometer will sense the translational acceleration (positional data) and the axis tilt (rotational data). The SmartDot will also have memory to store at least twenty-five samples of each sensor which is equal to twenty-five throws. The SmartDot will also have a bluetooth transmitter that will communicate with the mobile device through the ISmartDot interface. The ISmartDot interface will have several methods. It will have a couple methods for the mobile device to connect with the SmartDot module. It will also have read and write methods for sending and receiving data from the SmartDot. And finally, it will have methods for sending commands to the SmartDot. These commands will be strings. This will make the system more modular. These methods will define the communication between the SmartDot module and the mobile device.\nISmartDot Interface /// \u003csummary\u003e /// Interface representing the basic functionality of the Bluetooth connection between the mobile application and a SmartDot implementation (Simulator \u0026 Hardware) /// \u003c/summary\u003e public interface ISmartDot { /// \u003csummary\u003e /// Attempts to create a connection to the SmartDot hardware /// \u003c/summary\u003e /// \u003cparam name=\"connectionParameters\"\u003eConnection parameters\u003c/param\u003e /// \u003creturns\u003eversion representing the SmartDot hardware version (APIs use), null if unable to connect\u003c/returns\u003e public Task\u003cVersion?\u003e Connect(ConnectionParameters connectionParameters); /// \u003csummary\u003e /// Tests if the connection to the SmartDot hardware is present /// \u003c/summary\u003e /// \u003creturns\u003eBoolean representing if there is a connection to SmartDot hardware\u003c/returns\u003e public Task\u003cbool\u003e IsConnected(); /// \u003csummary\u003e /// Asynchronous method to write one page to the SmartDot implementation /// \u003c/summary\u003e /// \u003cparam name=\"address\"\u003eThe page start address in memory\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003eData (byte[]) to write to the SmartDot implementations page\u003c/param\u003e /// \u003cparam name=\"bytes\"\u003eLength of data to write from \u003cparamref name=\"buffer\"/\u003e\u003c/param\u003e /// \u003creturns\u003eA bool representing if call was successful\u003c/returns\u003e public Task\u003cSmartDotTransactionResult\u003e WriteBytes(long address, byte[] buffer, long bytes); /// \u003csummary\u003e /// Asynchronous method to read one page from the SmartDot implementation /// \u003c/summary\u003e /// \u003cparam name=\"address\"\u003eThe page start address in memory\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003eRef data (byte[]) read from the SmartDot implementations page (will attempt to fill completely)\u003c/param\u003e /// \u003cparam name=\"bytes\"\u003eLength of data to read into \u003cparamref name=\"buffer\"/\u003e\u003c/param\u003e /// \u003creturns\u003eA bool representing if call was successful\u003c/returns\u003e public Task\u003cSmartDotTransactionResult\u003e ReadBytes(long address, ref byte[] buffer, long bytes); /// \u003csummary\u003e /// Sends a command to the SmartDot hardware /// \u003c/summary\u003e /// \u003cparam name=\"command\"\u003eThe string command to send to the SmartDot hardware\u003c/param\u003e /// \u003creturns\u003eResult from the command execution on the SmartDot hardware\u003c/returns\u003e public Task\u003cstring\u003e OutgoingSmartDotCommand(string command); /// \u003csummary\u003e /// Invokes \u003csee cref=\"IncomingSmartDotCommandCallback\"/\u003e. Should be executed only from the implementor. /// \u003c/summary\u003e /// \u003cparam name=\"command\"\u003eString command called from SmartDot hardware\u003c/param\u003e protected virtual void RaiseIncomingSmartDotCommand(string command) =\u003e IncomingSmartDotCommandCallback?.Invoke(command); /// \u003csummary\u003e /// Incoming command callback (from SmartDot hardware). Signals from the SmartDot hardware that something important happened. /// \u003c/summary\u003e public Action\u003cstring\u003e? IncomingSmartDotCommandCallback { get; set; } }/// \u003csummary\u003e /// Enum representing the transaction result state of a communication with SmartDot hardware /// \u003c/summary\u003e public enum SmartDotTransactionResult : byte { /// \u003csummary\u003e /// SmartDot transaction succeeded /// \u003c/summary\u003e SUCCESS, /// \u003csummary\u003e /// SmartDot transaction failed - unknown cause /// \u003c/summary\u003e FAILURE_UNKNOWN, /// \u003csummary\u003e /// SmartDot transaction failed - data corruption /// \u003c/summary\u003e FAILURE_PERMISSION_ERROR, /// \u003csummary\u003e /// SmartDot transaction failed - device disconnected /// \u003c/summary\u003e FAILURE_DISCONNECTED, /// \u003csummary\u003e /// SmartDot transaction failed - data corruption /// \u003c/summary\u003e FAILURE_DATA_CORRUPTION }Unity Visualizer The Unity Visualizer is a Unity simulation that contains a lane, a ball, gutters, and pins. The Visualizer will utilize built-in Unity physics as well as realistic implemented physics in order to make the simulation as accurate as possible to an actual throw. The SmartDot Simulator will be used inside the Visualizer to get new data. Once the Visualizer is complete, it will be used to generate video files and simulated data in order to test other components of the project.\nUnity Camera The Unity Camera is a virtual camera that will exist within the Unity Visualizer. This camera will be set up to record throws within the Visualizer and export the recording as a video file. The video can then be read by the file reader on the mobile device and analyzed by the Ciclops application. Having a simulated video will also allow the Frontend Team to test finding a ball path prior to using actual video footage of real throws.\nUnity Simulated Data The Unity Simulated Data will be data that is gathered from the Unity Visualizer. When the simulation is run, data about the ball’s position, velocity, acceleration, angular velocity, and light level will be recorded and sent to the SmartDot Simulator for testing.\nClass Methods Unity Camera startRecord() endRecord() getVideo() Unity Visualizer setLoft(float h) setInitialVelocity(Vector3 velocity) setCurrentVelocity(Vector3 velocity) setCurrentAngularVelocity(Vector3 angle) setThrowPos(float x, float angle) setBallType(int id) setPinsLeft(int[10] pins) setOilPattern(float[][] pattern) getPinsLeft() getThrowNumber() getThrowRotations() getThrowCurve() getThrowVelocity() exportSimVideo() exportSimBinaryData() start() rollBall() pauseVisualizer() Unity Simulated Data No methods Existing Binary Dump File No methods SmartDot Memory read(int page) write(int page, int byte) SmartDot Bluetooth Transmitter readPage(int page) readPage(int ball_record_page) writePage(int page, int byte, string data) setDefault() Ambient Light Sensor sample() get_cur_time() start_up() check_valid_activation() 3-Axis Accelerometer sample_x() sample_y() sample_z() get_cur_time() Real Time Clock get_cur_time() ",
    "description": "Project Analysis and Design specific to the simulation team",
    "tags": null,
    "title": "Simulation Team",
    "uri": "/2024-capstone/project-assignments/fall-2023/analysis-and-design/simulation/index.html"
  },
  {
    "content": "\rISmartDot InterfaceInformation about the ISmartDot interface\nSmartDot HardwareInformation about the SmartDot hardware\nSmartDot SimulatorInformation about the SmartDot Simulator\n",
    "description": "",
    "tags": null,
    "title": "SmartDot",
    "uri": "/smartdot/index.html"
  },
  {
    "content": "",
    "description": "Information about the SmartDot hardware",
    "tags": null,
    "title": "SmartDot Hardware",
    "uri": "/smartdot/smartdothardware/index.html"
  },
  {
    "content": "Description The SmartDot Simulator will be used for sending test data from Visualizer to mobile app. The Visualizer will output csv files containing acceleration and light data. The SmartDot Simulator will imitate the SmartDot module in functionality with one difference. Instead of sampling real acceleration and light data, it will read the appropriate data from the csv file it got from the visualizer. The SmartDot Simulator will also create a binary file containing the data and will send it over bluetooth to the mobile app.\nPrerequisites Microsoft Office 365 - This is needed for your program to work with excel files\nGit\nDevelopment Enviroment The SmartDot Simulator is currently being developed in JetBrains Rider. This tutorial will show you to set up Rider and begin developing the Simulator. JetBrains Rider is a cross-platform .NET IDE based on the IntelliJ platform and ReSharper. Let’s get started!\nFirst, let’s install Rider.\nInstall Visual Studio if you do not already have it Make sure to include “.NET desktop development” in your installation. Install Rider if you don’t already have it Next, let’s configure it.\nClone the SM-Repo repository git@github.com:YCP-Rev-Metrix/SM-Repo.git Open the repository in Rider Open the NuGet package manager (Alt + Shift + 7) Add the following package Microsoft.Office.Interop.Excel Now, you are ready to start developing the SmartDot Simulator!! Have Fun!\n",
    "description": "How to setup your environment to develop the SmartDot Simulator",
    "tags": null,
    "title": "SmartDot Simulator",
    "uri": "/2024-capstone/how-to-contribute/getting-started/smartdot-simulator/index.html"
  },
  {
    "content": "SmartDot Architecture ",
    "description": "Information about the SmartDot Simulator",
    "tags": null,
    "title": "SmartDot Simulator",
    "uri": "/smartdot/smartdot-simulator/index.html"
  },
  {
    "content": "Overview Below you can find the list of project assignments completed throughout the spring 2024 semester and all of their details.\nList of Assignments Detailed Proposal and DesignInformation about the Detailed Proposal and Design assignment\n",
    "description": "A list of all assignments completed throughout the spring 2024 semester",
    "tags": null,
    "title": "Spring 2024",
    "uri": "/2024-capstone/project-assignments/spring-2024/index.html"
  },
  {
    "content": "Overview Below you can find the assignment descriptions for each of the project’s spring 2024 semester milestones. The appropriate slideshow can be seen under each milestone’s title.\nMilestones Milestone 1Progress made on milestone 1 and the associated slideshow\nMilestone 2Progress made on milestone 2 and the associated slideshow\nMilestone 3Progress made on milestone 3 and the associated slideshow\n",
    "description": "The progress made prior to each project milestone during the spring 2024 semester",
    "tags": null,
    "title": "Spring 2024",
    "uri": "/2024-capstone/project-milestones/spring-2024/index.html"
  },
  {
    "content": "Overview Below you’ll find a list of all the technologies necessary for making contributions to the RevMetrix project.\nTechnologies IDE’s Name Version Download Link JetBrains Rider 2023.2.3 Download JetBrains WebStorm 2023.3.4 Download Microsoft Visual Studio 2022 Community 17.7.5 Download Frameworks and tools Database Engines Name Version Download Link Microsoft SQL Server Developer 16.0.1000.6 Download SQL Server Management Studio 19 19.1 Download Design Tools Name Version Download Link Draw.io 21.6.8 Download Game Engine Name Version Download Link Unity Hub - Download Unity 2023.1.8 Download Java Development Kit 17 Name Version Download Link OpenJDK 17 17.0.9 LTS Download OS Virtualization Tools Name Version Download Link Docker Desktop 4.24.2 Release Notes Docker Engine 24.0.6 Release Notes Visual Studio Development Frameworks \u0026 Tools Name Version Download Link Common Azure Tools 1.10 Visual Studio Installation NuGet Package Manager 6.7.0 Visual Studio Installation Microsoft .NET Framework 4.8.09032 Visual Studio Installation .NET Multi-Platform App UI Development (MAUI) - Visual Studio Installation Razor (ASP.NET Core) 17.7.3.2333001 Visual Studio Installation SQL Server Data Tools 17.7.10.1 Visual Studio Installation Visual Studio IntelliCode 2.2 Optional checkbox under MAUI install Xamarin 17.0.0.223 Optional checkbox under MAUI install Web Development Frameworks Name Version Download Link Vue.js 5.08 Download Office 365 Name Version Download Link Microsoft Office 365 - Download ",
    "description": "A list of all of the necessary technologies to contribute to the project",
    "tags": null,
    "title": "Technologies Used",
    "uri": "/2024-capstone/technologies-used/index.html"
  },
  {
    "content": "Project Contributions Led Frontend Team to ensure Milestone goals were achieved Implemented Web API on Frontend Application Worked with Backend Team to expand implementations of Web API Devised efficient Github workflow for students working on Frontend application Assisted with implementing local database on Frontend application Explored Filesystem limitations of iOS devices using .NET MAUI application Implemented API Authentication by creating user-side Tokens on Frontend application Wrote numerous living documents specifying either the current or proposed future state of the project Contact Information Institution Email: tbloomquist@ycp.edu Phone Number: (443) 282-8229 External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Theodore Bloomquist",
    "uri": "/more/members/theodore-bloomquist/index.html"
  },
  {
    "content": "Project Contributions Assisted subteam in creation of weekly status update presentations Contact Information Institution Email: tbywaters@ycp.edu External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Thomas Bywaters",
    "uri": "/more/members/thomas-bywaters/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: vpineda@ycp.edu Phone Number: (717) 841-2599 External Links GitHub ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Victor Pineda",
    "uri": "/more/members/victor-pineda/index.html"
  },
  {
    "content": "Description The Visualizer will be used for generating test data for the system. It will will simulate the ball path as it travels down the lane and store the acceleration and light data that the SmartDOt would sample. It then writes that data into a CSV file and sends it to the SmartDot Simulator. The Visualizer also has a virtual camera that will record a video of the throw. The developers will hand this video off to the front end team to use in their Ciclops testing.\nPrerequisites Git\nDevelopment Environment The Visualizer is currently being developed in Unity. Unity is an open-source game engine that uses c# scripts for the programming. This tutorial will show you how to get started developing the Visualizer. Let’s get started!\nInstall Rider if you haven’t already Download and install Unity Hub on your machine Download the current appropriate Unity version. Reference the Technologies Used page Open Unity Hub on your machine Go to the “Installs” tab Select “Install Editor” Select the “Archive” tab Click “download archive” Select the appropriate Unity version and download the installer. Reference the Technologies Used page Install the selected version Now that you have Unity set up, let’s open the project\nClone git@github.com:YCP-Rev-Metrix/Simulation.git Open the project in Unity Select the “Edit” tab from the toolbar in the top left corner of the window Select “preferences” Select “External Tools” Set the “External Script Editor” field to “Rider” You’re all set!! Now you are ready to start developing the Visualizer. Good luck!\n",
    "description": "How to setup your environment to develop the Visualizer",
    "tags": null,
    "title": "Visualizer",
    "uri": "/2024-capstone/how-to-contribute/getting-started/visualizer/index.html"
  },
  {
    "content": "Table of Contents Stuff about NuGet package (github actions)\nInclude autogenerated swagger (github actions)\nShould hugo be re-run after cloud infrastructure actions?\nNuGet Package Swagger Documentation NuGet Package Things have changed, instead of pulling the project from GitHub, you can now use it from GitHub Packages as a standard NuGet package.\nIn order to do this, please add the RevMetrix GitHub as a NuGet source (may be called feeds in Rider). When adding this source, the name should be RevMetrix and the actual source will be https://nuget.pkg.github.com/YCP-Rev-Metrix/index.json.\nWe must now validate ourselves to this new source, go to github and add a classic token, set the expiration to one Year and be sure to select Read and Write permissions to Packages. (See example below). Create the token and copy the value (you will not be able to re-access). Now, go to add a package from RevMetrix just as you normally would, but this time you will be asked for a username and password. The username is your GitHub username and the password is the value of the token we created earlier.\nCongrats, you can now access RevMetrix private Packages. Please install the RevMetrix.Client.Api package, this will also install the Common one at the same time.\nSwagger Documentation ",
    "description": "Information regarding the Client side of the Web API",
    "tags": null,
    "title": "Web API Client",
    "uri": "/2024-capstone/how-to-contribute/webapi/client/index.html"
  },
  {
    "content": "Abstract The RevMetrix project is a project that seeks to capture a bowling ball’s motion as it travels down a lane. The project is based on two components developed initially by Professor Hake and Dr. Babcock. The first is the SmartDot module, developed by Professor Hake. The SmartDot module is a piece of hardware that sits inside the finger insert of the bowling ball. The next component is the Ciclopes software. Ciclopes is a motion detection software that can track and display the path traveled by a bowling ball with an uploaded video of a bowling ball shot. The RevMetrix team is building a device called a Ball Spinner. A Ball Spinner is a bowling analysis tool that recreates the movement and rotation of a bowling ball during a game. The bowling ball sits in an enclosure where it is pressed against three motors, allowing it to spin in three orthogonal axes. Users can simulate shots through an application interface by entering input parameters for the shot, where these parameters are sent to the Ball Spinner, and the motors move the bowling ball as if it were actually on a bowling lane. Complex physics equations will account for the input parameters and the other external conditions to calculate instructions for the motors to move the ball as realistically as possible. A SmartDot module that resides in the ball allows users to visualize what it would be doing if it moved on a lane and store shots for later replaying/analyzing previous shots. In this paper, we will provide more context behind the RevMetrix project and any important concepts needed to understand our work, go over both the design and the implementation of each of the aspects of our project, and discuss any future work that still needs to be completed for the project.\nIntroduction The RevMetrix project seeks to provide its users with a set of hardware and software to capture a bowling ball’s internal and external metrics. The approach to achieving this goal was to design a device capable of driving a bowling ball in three orthogonal axes. Accompanying this device will be a controller module capable of controlling the motors on the device and communicating with an application. This application provides users with an interface for creating simulated shots, where the users can enter parameters representing shot dynamics. The controller module will then be sent motor instructions from the application, based on kinematic models, using the parameters combined with other environment factors. The controller will then drive the physical device, where simultaneously, the application will display a simulation representing what is happening on the physical device using sensor data returned from a piece of hardware residing within the finger insert of the bowling ball. Thus, a significant focus will be on ensuring the quality and reliability of this module through thorough testing and validation. Each of the components that allow our system to fulfill these requirements are described below: Ball Spinner Controller: The communication module responsible for facilitating communication between the Ball Spinner Application and the Ball Spinner device. Instructions from the application can be sent to the Ball Spinner from the Ball Spinner Controller, as well as SmartDot feedback data that can be sent back to the application. Ball Spinner Application: Software that can be used to simulate a bowling shot via the Ball Spinner device. Data is collected representing the dynamics of the simulated shot from the SmartDot module residing on the bowling ball. The Ball Spinner Application will facilitate communication with the Ball Spinner device and the SmartDot module through a TCP connection with the Ball Spinner Controller. Ball Spinner: The enclosed physical device that will simulate the bowling balls movement based on user input from the application. The Ball Spinner will contain motors that drive the ball, as specified by the motor instructions sent by the Ball Spinner Controller. SmartDot Module: Device that contains an embedded accelerometer, gyroscope, magnetometer, and ambient light sensor. This device will be placed within the bowling ball, and will send data collected from the sensors back to the Ball Spinner Controller, to then be sent to the application.\nThe Problem The problem our system addresses is the lack of calibration and testing environments for the SmartDot. The future SmartDot module device and the creation of the testing environment for the future SmartDot module are integral requirements for this project as well. The system will also provide functionality to allow a user to analyze and review previous shot data, enabling them to leverage our platform to evaluate the effects of various factors on a bowling shot. Since the Ball Spinner device uses physical motors to drive the ball, we must ensure that the instructions we send to the motors move the ball to the specified speed. Since the SmartDot module is still under development, once the Ball Spinner is calibrated, this will also foster a testing environment for Professor Hake to test the module’s functionality.\n",
    "description": "2025 Capstone",
    "tags": null,
    "title": "What is RevMetrix",
    "uri": "/what-is-revmetrix/index.html"
  },
  {
    "content": "Project Contributions Contact Information Institution Email: External Links ",
    "description": "External links to member and information about their contributions",
    "tags": null,
    "title": "Zach Cox",
    "uri": "/more/members/zach-cox/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "Faculty Contributors Professor Donald Hake II Dr. David Babcock 2025 Student Contributors Simulation Development team\nAndrew Watkins (Fall 2024 and Spring 2025) Carson Mack (Spring 2025) Frontend Development Team\nPatrick Devine (Fall 2024 and Spring 2025) Backend Development Team\nRyan Curry (Fall 2024 and Spring 2025) Josh Byers (Spring 2025) Brandon Woodward (Spring 2025) Wiki\nAndrew Watkins (Fall 2024 and Spring 2025) Carson Mack (Spring 2025) Josh Byers (Spring 2025) Zach (Spring 2025) Ball Spinner Contoller Team\nRobert Fields (Fall 2024 and Spring 2025) Zach Cox (Spring 2025) Brandon Woodward (Spring 2025) Ball Spinner Team\nSam (Fall 2024 and Spring 2025) Chris (Fall 2024 and Spring 2025) David (Fall 2024 and Spring 2025) Cellular\nCarson Mack (Spring 2025) Josh Byers (Spring 2025) Zach (Spring 2025) Thomas Bywaters (Spring 2025) 2024 Student Contributors Simulation / Graphics Team\nLuke Dodson (Fa23, Sp24) Bryce Neptune (Fa23, Sp24) Enoch Sam (Fa23, Sp24) Ian Viveiros (Fa23) Frontend Development Team\nTheodore Bloomquist (Fa23, Sp24) Michael Hensel (Fa23, Sp24) John Kettula (Fa23) Liz Mains (Fa23, Sp24) Backend Development Team\nJordan Carvell (Fa23) Braden Fleming (Fa23) Victor Pineda (Fa23, Sp24) Robert Wood (Fa23, Sp24) ",
    "description": "",
    "tags": null,
    "title": "Credits",
    "uri": "/more/credits/index.html"
  },
  {
    "content": "Welcome to RevMetrix Quick Links 2024 Capstone 2025 Capstone Ciclopes SmartDot What is RevMetrix ",
    "description": "",
    "tags": null,
    "title": "RevMetrix",
    "uri": "/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
